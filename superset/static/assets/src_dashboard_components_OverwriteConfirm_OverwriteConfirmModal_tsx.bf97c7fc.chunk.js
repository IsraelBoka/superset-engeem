/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunksuperset"] = globalThis["webpackChunksuperset"] || []).push([["src_dashboard_components_OverwriteConfirm_OverwriteConfirmModal_tsx"],{

/***/ "./node_modules/emotion/dist/emotion.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/emotion/dist/emotion.esm.js ***!
  \**************************************************/
/***/ (() => {

throw new Error("Module build failed: Error: ENOENT: no such file or directory, open '/app/superset-frontend/node_modules/emotion/dist/emotion.esm.js'");

/***/ }),

/***/ "./node_modules/react-diff-viewer-continued/lib/compute-lines.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-diff-viewer-continued/lib/compute-lines.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.computeLineInformation = exports.DiffMethod = exports.DiffType = void 0;\nconst diff = __webpack_require__(/*! diff */ \"./node_modules/react-diff-viewer-continued/node_modules/diff/lib/index.js\");\nconst jsDiff = diff;\nvar DiffType;\n(function (DiffType) {\n    DiffType[DiffType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n    DiffType[DiffType[\"ADDED\"] = 1] = \"ADDED\";\n    DiffType[DiffType[\"REMOVED\"] = 2] = \"REMOVED\";\n    DiffType[DiffType[\"CHANGED\"] = 3] = \"CHANGED\";\n})(DiffType = exports.DiffType || (exports.DiffType = {}));\n// See https://github.com/kpdecker/jsdiff/tree/v4.0.1#api for more info on the below JsDiff methods\nvar DiffMethod;\n(function (DiffMethod) {\n    DiffMethod[\"CHARS\"] = \"diffChars\";\n    DiffMethod[\"WORDS\"] = \"diffWords\";\n    DiffMethod[\"WORDS_WITH_SPACE\"] = \"diffWordsWithSpace\";\n    DiffMethod[\"LINES\"] = \"diffLines\";\n    DiffMethod[\"TRIMMED_LINES\"] = \"diffTrimmedLines\";\n    DiffMethod[\"SENTENCES\"] = \"diffSentences\";\n    DiffMethod[\"CSS\"] = \"diffCss\";\n    DiffMethod[\"JSON\"] = \"diffJson\";\n})(DiffMethod = exports.DiffMethod || (exports.DiffMethod = {}));\n/**\n * Splits diff text by new line and computes final list of diff lines based on\n * conditions.\n *\n * @param value Diff text from the js diff module.\n */\nconst constructLines = (value) => {\n    if (value === '')\n        return [];\n    const lines = value.replace(/\\n$/, '').split('\\n');\n    return lines;\n};\n/**\n * Computes word diff information in the line.\n * [TODO]: Consider adding options argument for JsDiff text block comparison\n *\n * @param oldValue Old word in the line.\n * @param newValue New word in the line.\n * @param compareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n */\nconst computeDiff = (oldValue, newValue, compareMethod = DiffMethod.CHARS) => {\n    const diffArray = jsDiff[compareMethod](oldValue, newValue);\n    const computedDiff = {\n        left: [],\n        right: [],\n    };\n    diffArray.forEach(({ added, removed, value }) => {\n        const diffInformation = {};\n        if (added) {\n            diffInformation.type = DiffType.ADDED;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n        }\n        if (removed) {\n            diffInformation.type = DiffType.REMOVED;\n            diffInformation.value = value;\n            computedDiff.left.push(diffInformation);\n        }\n        if (!removed && !added) {\n            diffInformation.type = DiffType.DEFAULT;\n            diffInformation.value = value;\n            computedDiff.right.push(diffInformation);\n            computedDiff.left.push(diffInformation);\n        }\n        return diffInformation;\n    });\n    return computedDiff;\n};\n/**\n * [TODO]: Think about moving common left and right value assignment to a\n * common place. Better readability?\n *\n * Computes line wise information based in the js diff information passed. Each\n * line contains information about left and right section. Left side denotes\n * deletion and right side denotes addition.\n *\n * @param oldString Old string to compare.\n * @param newString New string to compare with old string.\n * @param disableWordDiff Flag to enable/disable word diff.\n * @param lineCompareMethod JsDiff text diff method from https://github.com/kpdecker/jsdiff/tree/v4.0.1#api\n * @param linesOffset line number to start counting from\n */\nconst computeLineInformation = (oldString, newString, disableWordDiff = false, lineCompareMethod = DiffMethod.CHARS, linesOffset = 0) => {\n    let diffArray = [];\n    // Use diffLines for strings, and diffJson for objects...\n    if (typeof oldString === 'string' && typeof newString === 'string') {\n        diffArray = diff.diffLines(oldString.trimRight(), newString.trimRight(), {\n            newlineIsToken: false,\n            ignoreWhitespace: false,\n            ignoreCase: false,\n        });\n    }\n    else {\n        diffArray = diff.diffJson(oldString, newString);\n    }\n    let rightLineNumber = linesOffset;\n    let leftLineNumber = linesOffset;\n    let lineInformation = [];\n    let counter = 0;\n    const diffLines = [];\n    const ignoreDiffIndexes = [];\n    const getLineInformation = (value, diffIndex, added, removed, evaluateOnlyFirstLine) => {\n        const lines = constructLines(value);\n        return lines\n            .map((line, lineIndex) => {\n            const left = {};\n            const right = {};\n            if (ignoreDiffIndexes.includes(`${diffIndex}-${lineIndex}`) ||\n                (evaluateOnlyFirstLine && lineIndex !== 0)) {\n                return undefined;\n            }\n            if (added || removed) {\n                let countAsChange = true;\n                if (removed) {\n                    leftLineNumber += 1;\n                    left.lineNumber = leftLineNumber;\n                    left.type = DiffType.REMOVED;\n                    left.value = line || ' ';\n                    // When the current line is of type REMOVED, check the next item in\n                    // the diff array whether it is of type ADDED. If true, the current\n                    // diff will be marked as both REMOVED and ADDED. Meaning, the\n                    // current line is a modification.\n                    const nextDiff = diffArray[diffIndex + 1];\n                    if (nextDiff && nextDiff.added) {\n                        const nextDiffLines = constructLines(nextDiff.value)[lineIndex];\n                        if (nextDiffLines) {\n                            const nextDiffLineInfo = getLineInformation(nextDiffLines, diffIndex, true, false, true);\n                            const { value: rightValue, lineNumber, type, } = nextDiffLineInfo[0].right;\n                            // When identified as modification, push the next diff to ignore\n                            // list as the next value will be added in this line computation as\n                            // right and left values.\n                            ignoreDiffIndexes.push(`${diffIndex + 1}-${lineIndex}`);\n                            right.lineNumber = lineNumber;\n                            if (left.value === rightValue) {\n                                // The new value is exactly the same as the old\n                                countAsChange = false;\n                                right.type = 0;\n                                left.type = 0;\n                                right.value = rightValue;\n                            }\n                            else {\n                                right.type = type;\n                                // Do char level diff and assign the corresponding values to the\n                                // left and right diff information object.\n                                if (disableWordDiff) {\n                                    right.value = rightValue;\n                                }\n                                else {\n                                    const computedDiff = computeDiff(line, rightValue, lineCompareMethod);\n                                    right.value = computedDiff.right;\n                                    left.value = computedDiff.left;\n                                }\n                            }\n                        }\n                    }\n                }\n                else {\n                    rightLineNumber += 1;\n                    right.lineNumber = rightLineNumber;\n                    right.type = DiffType.ADDED;\n                    right.value = line;\n                }\n                if (countAsChange && !evaluateOnlyFirstLine) {\n                    if (!diffLines.includes(counter)) {\n                        diffLines.push(counter);\n                    }\n                }\n            }\n            else {\n                leftLineNumber += 1;\n                rightLineNumber += 1;\n                left.lineNumber = leftLineNumber;\n                left.type = DiffType.DEFAULT;\n                left.value = line;\n                right.lineNumber = rightLineNumber;\n                right.type = DiffType.DEFAULT;\n                right.value = line;\n            }\n            if (!evaluateOnlyFirstLine) {\n                counter += 1;\n            }\n            return { right, left };\n        })\n            .filter(Boolean);\n    };\n    diffArray.forEach(({ added, removed, value }, index) => {\n        lineInformation = [\n            ...lineInformation,\n            ...getLineInformation(value, index, added, removed),\n        ];\n    });\n    return {\n        lineInformation,\n        diffLines,\n    };\n};\nexports.computeLineInformation = computeLineInformation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9jb21wdXRlLWxpbmVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZC9saWIvY29tcHV0ZS1saW5lcy5qcz9kYjA3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wdXRlTGluZUluZm9ybWF0aW9uID0gZXhwb3J0cy5EaWZmTWV0aG9kID0gZXhwb3J0cy5EaWZmVHlwZSA9IHZvaWQgMDtcbmNvbnN0IGRpZmYgPSByZXF1aXJlKFwiZGlmZlwiKTtcbmNvbnN0IGpzRGlmZiA9IGRpZmY7XG52YXIgRGlmZlR5cGU7XG4oZnVuY3Rpb24gKERpZmZUeXBlKSB7XG4gICAgRGlmZlR5cGVbRGlmZlR5cGVbXCJERUZBVUxUXCJdID0gMF0gPSBcIkRFRkFVTFRcIjtcbiAgICBEaWZmVHlwZVtEaWZmVHlwZVtcIkFEREVEXCJdID0gMV0gPSBcIkFEREVEXCI7XG4gICAgRGlmZlR5cGVbRGlmZlR5cGVbXCJSRU1PVkVEXCJdID0gMl0gPSBcIlJFTU9WRURcIjtcbiAgICBEaWZmVHlwZVtEaWZmVHlwZVtcIkNIQU5HRURcIl0gPSAzXSA9IFwiQ0hBTkdFRFwiO1xufSkoRGlmZlR5cGUgPSBleHBvcnRzLkRpZmZUeXBlIHx8IChleHBvcnRzLkRpZmZUeXBlID0ge30pKTtcbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20va3BkZWNrZXIvanNkaWZmL3RyZWUvdjQuMC4xI2FwaSBmb3IgbW9yZSBpbmZvIG9uIHRoZSBiZWxvdyBKc0RpZmYgbWV0aG9kc1xudmFyIERpZmZNZXRob2Q7XG4oZnVuY3Rpb24gKERpZmZNZXRob2QpIHtcbiAgICBEaWZmTWV0aG9kW1wiQ0hBUlNcIl0gPSBcImRpZmZDaGFyc1wiO1xuICAgIERpZmZNZXRob2RbXCJXT1JEU1wiXSA9IFwiZGlmZldvcmRzXCI7XG4gICAgRGlmZk1ldGhvZFtcIldPUkRTX1dJVEhfU1BBQ0VcIl0gPSBcImRpZmZXb3Jkc1dpdGhTcGFjZVwiO1xuICAgIERpZmZNZXRob2RbXCJMSU5FU1wiXSA9IFwiZGlmZkxpbmVzXCI7XG4gICAgRGlmZk1ldGhvZFtcIlRSSU1NRURfTElORVNcIl0gPSBcImRpZmZUcmltbWVkTGluZXNcIjtcbiAgICBEaWZmTWV0aG9kW1wiU0VOVEVOQ0VTXCJdID0gXCJkaWZmU2VudGVuY2VzXCI7XG4gICAgRGlmZk1ldGhvZFtcIkNTU1wiXSA9IFwiZGlmZkNzc1wiO1xuICAgIERpZmZNZXRob2RbXCJKU09OXCJdID0gXCJkaWZmSnNvblwiO1xufSkoRGlmZk1ldGhvZCA9IGV4cG9ydHMuRGlmZk1ldGhvZCB8fCAoZXhwb3J0cy5EaWZmTWV0aG9kID0ge30pKTtcbi8qKlxuICogU3BsaXRzIGRpZmYgdGV4dCBieSBuZXcgbGluZSBhbmQgY29tcHV0ZXMgZmluYWwgbGlzdCBvZiBkaWZmIGxpbmVzIGJhc2VkIG9uXG4gKiBjb25kaXRpb25zLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSBEaWZmIHRleHQgZnJvbSB0aGUganMgZGlmZiBtb2R1bGUuXG4gKi9cbmNvbnN0IGNvbnN0cnVjdExpbmVzID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09PSAnJylcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGxpbmVzID0gdmFsdWUucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJyk7XG4gICAgcmV0dXJuIGxpbmVzO1xufTtcbi8qKlxuICogQ29tcHV0ZXMgd29yZCBkaWZmIGluZm9ybWF0aW9uIGluIHRoZSBsaW5lLlxuICogW1RPRE9dOiBDb25zaWRlciBhZGRpbmcgb3B0aW9ucyBhcmd1bWVudCBmb3IgSnNEaWZmIHRleHQgYmxvY2sgY29tcGFyaXNvblxuICpcbiAqIEBwYXJhbSBvbGRWYWx1ZSBPbGQgd29yZCBpbiB0aGUgbGluZS5cbiAqIEBwYXJhbSBuZXdWYWx1ZSBOZXcgd29yZCBpbiB0aGUgbGluZS5cbiAqIEBwYXJhbSBjb21wYXJlTWV0aG9kIEpzRGlmZiB0ZXh0IGRpZmYgbWV0aG9kIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2twZGVja2VyL2pzZGlmZi90cmVlL3Y0LjAuMSNhcGlcbiAqL1xuY29uc3QgY29tcHV0ZURpZmYgPSAob2xkVmFsdWUsIG5ld1ZhbHVlLCBjb21wYXJlTWV0aG9kID0gRGlmZk1ldGhvZC5DSEFSUykgPT4ge1xuICAgIGNvbnN0IGRpZmZBcnJheSA9IGpzRGlmZltjb21wYXJlTWV0aG9kXShvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgIGNvbnN0IGNvbXB1dGVkRGlmZiA9IHtcbiAgICAgICAgbGVmdDogW10sXG4gICAgICAgIHJpZ2h0OiBbXSxcbiAgICB9O1xuICAgIGRpZmZBcnJheS5mb3JFYWNoKCh7IGFkZGVkLCByZW1vdmVkLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZmZJbmZvcm1hdGlvbiA9IHt9O1xuICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi50eXBlID0gRGlmZlR5cGUuQURERUQ7XG4gICAgICAgICAgICBkaWZmSW5mb3JtYXRpb24udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbXB1dGVkRGlmZi5yaWdodC5wdXNoKGRpZmZJbmZvcm1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi50eXBlID0gRGlmZlR5cGUuUkVNT1ZFRDtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29tcHV0ZWREaWZmLmxlZnQucHVzaChkaWZmSW5mb3JtYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVtb3ZlZCAmJiAhYWRkZWQpIHtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi50eXBlID0gRGlmZlR5cGUuREVGQVVMVDtcbiAgICAgICAgICAgIGRpZmZJbmZvcm1hdGlvbi52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgY29tcHV0ZWREaWZmLnJpZ2h0LnB1c2goZGlmZkluZm9ybWF0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVkRGlmZi5sZWZ0LnB1c2goZGlmZkluZm9ybWF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZkluZm9ybWF0aW9uO1xuICAgIH0pO1xuICAgIHJldHVybiBjb21wdXRlZERpZmY7XG59O1xuLyoqXG4gKiBbVE9ET106IFRoaW5rIGFib3V0IG1vdmluZyBjb21tb24gbGVmdCBhbmQgcmlnaHQgdmFsdWUgYXNzaWdubWVudCB0byBhXG4gKiBjb21tb24gcGxhY2UuIEJldHRlciByZWFkYWJpbGl0eT9cbiAqXG4gKiBDb21wdXRlcyBsaW5lIHdpc2UgaW5mb3JtYXRpb24gYmFzZWQgaW4gdGhlIGpzIGRpZmYgaW5mb3JtYXRpb24gcGFzc2VkLiBFYWNoXG4gKiBsaW5lIGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IGxlZnQgYW5kIHJpZ2h0IHNlY3Rpb24uIExlZnQgc2lkZSBkZW5vdGVzXG4gKiBkZWxldGlvbiBhbmQgcmlnaHQgc2lkZSBkZW5vdGVzIGFkZGl0aW9uLlxuICpcbiAqIEBwYXJhbSBvbGRTdHJpbmcgT2xkIHN0cmluZyB0byBjb21wYXJlLlxuICogQHBhcmFtIG5ld1N0cmluZyBOZXcgc3RyaW5nIHRvIGNvbXBhcmUgd2l0aCBvbGQgc3RyaW5nLlxuICogQHBhcmFtIGRpc2FibGVXb3JkRGlmZiBGbGFnIHRvIGVuYWJsZS9kaXNhYmxlIHdvcmQgZGlmZi5cbiAqIEBwYXJhbSBsaW5lQ29tcGFyZU1ldGhvZCBKc0RpZmYgdGV4dCBkaWZmIG1ldGhvZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvdHJlZS92NC4wLjEjYXBpXG4gKiBAcGFyYW0gbGluZXNPZmZzZXQgbGluZSBudW1iZXIgdG8gc3RhcnQgY291bnRpbmcgZnJvbVxuICovXG5jb25zdCBjb21wdXRlTGluZUluZm9ybWF0aW9uID0gKG9sZFN0cmluZywgbmV3U3RyaW5nLCBkaXNhYmxlV29yZERpZmYgPSBmYWxzZSwgbGluZUNvbXBhcmVNZXRob2QgPSBEaWZmTWV0aG9kLkNIQVJTLCBsaW5lc09mZnNldCA9IDApID0+IHtcbiAgICBsZXQgZGlmZkFycmF5ID0gW107XG4gICAgLy8gVXNlIGRpZmZMaW5lcyBmb3Igc3RyaW5ncywgYW5kIGRpZmZKc29uIGZvciBvYmplY3RzLi4uXG4gICAgaWYgKHR5cGVvZiBvbGRTdHJpbmcgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBuZXdTdHJpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRpZmZBcnJheSA9IGRpZmYuZGlmZkxpbmVzKG9sZFN0cmluZy50cmltUmlnaHQoKSwgbmV3U3RyaW5nLnRyaW1SaWdodCgpLCB7XG4gICAgICAgICAgICBuZXdsaW5lSXNUb2tlbjogZmFsc2UsXG4gICAgICAgICAgICBpZ25vcmVXaGl0ZXNwYWNlOiBmYWxzZSxcbiAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRpZmZBcnJheSA9IGRpZmYuZGlmZkpzb24ob2xkU3RyaW5nLCBuZXdTdHJpbmcpO1xuICAgIH1cbiAgICBsZXQgcmlnaHRMaW5lTnVtYmVyID0gbGluZXNPZmZzZXQ7XG4gICAgbGV0IGxlZnRMaW5lTnVtYmVyID0gbGluZXNPZmZzZXQ7XG4gICAgbGV0IGxpbmVJbmZvcm1hdGlvbiA9IFtdO1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBjb25zdCBkaWZmTGluZXMgPSBbXTtcbiAgICBjb25zdCBpZ25vcmVEaWZmSW5kZXhlcyA9IFtdO1xuICAgIGNvbnN0IGdldExpbmVJbmZvcm1hdGlvbiA9ICh2YWx1ZSwgZGlmZkluZGV4LCBhZGRlZCwgcmVtb3ZlZCwgZXZhbHVhdGVPbmx5Rmlyc3RMaW5lKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gY29uc3RydWN0TGluZXModmFsdWUpO1xuICAgICAgICByZXR1cm4gbGluZXNcbiAgICAgICAgICAgIC5tYXAoKGxpbmUsIGxpbmVJbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB7fTtcbiAgICAgICAgICAgIGlmIChpZ25vcmVEaWZmSW5kZXhlcy5pbmNsdWRlcyhgJHtkaWZmSW5kZXh9LSR7bGluZUluZGV4fWApIHx8XG4gICAgICAgICAgICAgICAgKGV2YWx1YXRlT25seUZpcnN0TGluZSAmJiBsaW5lSW5kZXggIT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRlZCB8fCByZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvdW50QXNDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQubGluZU51bWJlciA9IGxlZnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LnR5cGUgPSBEaWZmVHlwZS5SRU1PVkVEO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LnZhbHVlID0gbGluZSB8fCAnICc7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGN1cnJlbnQgbGluZSBpcyBvZiB0eXBlIFJFTU9WRUQsIGNoZWNrIHRoZSBuZXh0IGl0ZW0gaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRpZmYgYXJyYXkgd2hldGhlciBpdCBpcyBvZiB0eXBlIEFEREVELiBJZiB0cnVlLCB0aGUgY3VycmVudFxuICAgICAgICAgICAgICAgICAgICAvLyBkaWZmIHdpbGwgYmUgbWFya2VkIGFzIGJvdGggUkVNT1ZFRCBhbmQgQURERUQuIE1lYW5pbmcsIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGxpbmUgaXMgYSBtb2RpZmljYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREaWZmID0gZGlmZkFycmF5W2RpZmZJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dERpZmYgJiYgbmV4dERpZmYuYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREaWZmTGluZXMgPSBjb25zdHJ1Y3RMaW5lcyhuZXh0RGlmZi52YWx1ZSlbbGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0RGlmZkxpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dERpZmZMaW5lSW5mbyA9IGdldExpbmVJbmZvcm1hdGlvbihuZXh0RGlmZkxpbmVzLCBkaWZmSW5kZXgsIHRydWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiByaWdodFZhbHVlLCBsaW5lTnVtYmVyLCB0eXBlLCB9ID0gbmV4dERpZmZMaW5lSW5mb1swXS5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGlkZW50aWZpZWQgYXMgbW9kaWZpY2F0aW9uLCBwdXNoIHRoZSBuZXh0IGRpZmYgdG8gaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBhcyB0aGUgbmV4dCB2YWx1ZSB3aWxsIGJlIGFkZGVkIGluIHRoaXMgbGluZSBjb21wdXRhdGlvbiBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGFuZCBsZWZ0IHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVEaWZmSW5kZXhlcy5wdXNoKGAke2RpZmZJbmRleCArIDF9LSR7bGluZUluZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0LnZhbHVlID09PSByaWdodFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgdmFsdWUgaXMgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgb2xkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50QXNDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQudHlwZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnZhbHVlID0gcmlnaHRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0LnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEbyBjaGFyIGxldmVsIGRpZmYgYW5kIGFzc2lnbiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxlZnQgYW5kIHJpZ2h0IGRpZmYgaW5mb3JtYXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzYWJsZVdvcmREaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC52YWx1ZSA9IHJpZ2h0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wdXRlZERpZmYgPSBjb21wdXRlRGlmZihsaW5lLCByaWdodFZhbHVlLCBsaW5lQ29tcGFyZU1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodC52YWx1ZSA9IGNvbXB1dGVkRGlmZi5yaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQudmFsdWUgPSBjb21wdXRlZERpZmYubGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LmxpbmVOdW1iZXIgPSByaWdodExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0LnR5cGUgPSBEaWZmVHlwZS5BRERFRDtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQudmFsdWUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY291bnRBc0NoYW5nZSAmJiAhZXZhbHVhdGVPbmx5Rmlyc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlmZkxpbmVzLmluY2x1ZGVzKGNvdW50ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmTGluZXMucHVzaChjb3VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgcmlnaHRMaW5lTnVtYmVyICs9IDE7XG4gICAgICAgICAgICAgICAgbGVmdC5saW5lTnVtYmVyID0gbGVmdExpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgbGVmdC50eXBlID0gRGlmZlR5cGUuREVGQVVMVDtcbiAgICAgICAgICAgICAgICBsZWZ0LnZhbHVlID0gbGluZTtcbiAgICAgICAgICAgICAgICByaWdodC5saW5lTnVtYmVyID0gcmlnaHRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgICAgIHJpZ2h0LnR5cGUgPSBEaWZmVHlwZS5ERUZBVUxUO1xuICAgICAgICAgICAgICAgIHJpZ2h0LnZhbHVlID0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZXZhbHVhdGVPbmx5Rmlyc3RMaW5lKSB7XG4gICAgICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgcmlnaHQsIGxlZnQgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbik7XG4gICAgfTtcbiAgICBkaWZmQXJyYXkuZm9yRWFjaCgoeyBhZGRlZCwgcmVtb3ZlZCwgdmFsdWUgfSwgaW5kZXgpID0+IHtcbiAgICAgICAgbGluZUluZm9ybWF0aW9uID0gW1xuICAgICAgICAgICAgLi4ubGluZUluZm9ybWF0aW9uLFxuICAgICAgICAgICAgLi4uZ2V0TGluZUluZm9ybWF0aW9uKHZhbHVlLCBpbmRleCwgYWRkZWQsIHJlbW92ZWQpLFxuICAgICAgICBdO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVJbmZvcm1hdGlvbixcbiAgICAgICAgZGlmZkxpbmVzLFxuICAgIH07XG59O1xuZXhwb3J0cy5jb21wdXRlTGluZUluZm9ybWF0aW9uID0gY29tcHV0ZUxpbmVJbmZvcm1hdGlvbjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-diff-viewer-continued/lib/compute-lines.js\n");

/***/ }),

/***/ "./node_modules/react-diff-viewer-continued/lib/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-diff-viewer-continued/lib/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("var __webpack_unused_export__;\n\n__webpack_unused_export__ = ({ value: true });\n__webpack_unused_export__ = exports.LineNumberPrefix = void 0;\nconst React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst PropTypes = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\nconst classnames_1 = __webpack_require__(/*! classnames */ \"./node_modules/classnames/index.js\");\nconst compute_lines_1 = __webpack_require__(/*! ./compute-lines */ \"./node_modules/react-diff-viewer-continued/lib/compute-lines.js\");\n__webpack_unused_export__ = ({ enumerable: true, get: function () { return compute_lines_1.DiffMethod; } });\nconst styles_1 = __webpack_require__(/*! ./styles */ \"./node_modules/react-diff-viewer-continued/lib/styles.js\");\nconst m = __webpack_require__(/*! memoize-one */ \"./node_modules/react-diff-viewer-continued/node_modules/memoize-one/dist/memoize-one.esm.js\");\nconst memoize = m.default || m;\nvar LineNumberPrefix;\n(function (LineNumberPrefix) {\n    LineNumberPrefix[\"LEFT\"] = \"L\";\n    LineNumberPrefix[\"RIGHT\"] = \"R\";\n})(LineNumberPrefix = exports.LineNumberPrefix || (exports.LineNumberPrefix = {}));\nclass DiffViewer extends React.Component {\n    constructor(props) {\n        super(props);\n        /**\n         * Resets code block expand to the initial stage. Will be exposed to the parent component via\n         * refs.\n         */\n        this.resetCodeBlocks = () => {\n            if (this.state.expandedBlocks.length > 0) {\n                this.setState({\n                    expandedBlocks: [],\n                });\n                return true;\n            }\n            return false;\n        };\n        /**\n         * Pushes the target expanded code block to the state. During the re-render,\n         * this value is used to expand/fold unmodified code.\n         */\n        this.onBlockExpand = (id) => {\n            const prevState = this.state.expandedBlocks.slice();\n            prevState.push(id);\n            this.setState({\n                expandedBlocks: prevState,\n            });\n        };\n        /**\n         * Computes final styles for the diff viewer. It combines the default styles with the user\n         * supplied overrides. The computed styles are cached with performance in mind.\n         *\n         * @param styles User supplied style overrides.\n         */\n        this.computeStyles = memoize(styles_1.default);\n        /**\n         * Returns a function with clicked line number in the closure. Returns an no-op function when no\n         * onLineNumberClick handler is supplied.\n         *\n         * @param id Line id of a line.\n         */\n        this.onLineNumberClickProxy = (id) => {\n            if (this.props.onLineNumberClick) {\n                return (e) => this.props.onLineNumberClick(id, e);\n            }\n            return () => { };\n        };\n        /**\n         * Maps over the word diff and constructs the required React elements to show word diff.\n         *\n         * @param diffArray Word diff information derived from line information.\n         * @param renderer Optional renderer to format diff words. Useful for syntax highlighting.\n         */\n        this.renderWordDiff = (diffArray, renderer) => {\n            return diffArray.map((wordDiff, i) => {\n                return (React.createElement(\"span\", { key: i, className: (0, classnames_1.default)(this.styles.wordDiff, {\n                        [this.styles.wordAdded]: wordDiff.type === compute_lines_1.DiffType.ADDED,\n                        [this.styles.wordRemoved]: wordDiff.type === compute_lines_1.DiffType.REMOVED,\n                    }) }, renderer ? renderer(wordDiff.value) : wordDiff.value));\n            });\n        };\n        /**\n         * Maps over the line diff and constructs the required react elements to show line diff. It calls\n         * renderWordDiff when encountering word diff. This takes care of both inline and split view line\n         * renders.\n         *\n         * @param lineNumber Line number of the current line.\n         * @param type Type of diff of the current line.\n         * @param prefix Unique id to prefix with the line numbers.\n         * @param value Content of the line. It can be a string or a word diff array.\n         * @param additionalLineNumber Additional line number to be shown. Useful for rendering inline\n         *  diff view. Right line number will be passed as additionalLineNumber.\n         * @param additionalPrefix Similar to prefix but for additional line number.\n         */\n        this.renderLine = (lineNumber, type, prefix, value, additionalLineNumber, additionalPrefix) => {\n            const lineNumberTemplate = `${prefix}-${lineNumber}`;\n            const additionalLineNumberTemplate = `${additionalPrefix}-${additionalLineNumber}`;\n            const highlightLine = this.props.highlightLines.includes(lineNumberTemplate) ||\n                this.props.highlightLines.includes(additionalLineNumberTemplate);\n            const added = type === compute_lines_1.DiffType.ADDED;\n            const removed = type === compute_lines_1.DiffType.REMOVED;\n            const changed = type === compute_lines_1.DiffType.CHANGED;\n            let content;\n            if (Array.isArray(value)) {\n                content = this.renderWordDiff(value, this.props.renderContent);\n            }\n            else if (this.props.renderContent) {\n                content = this.props.renderContent(value);\n            }\n            else {\n                content = value;\n            }\n            return (React.createElement(React.Fragment, null,\n                !this.props.hideLineNumbers && (React.createElement(\"td\", { onClick: lineNumber && this.onLineNumberClickProxy(lineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                        [this.styles.emptyGutter]: !lineNumber,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedGutter]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.lineNumber }, lineNumber))),\n                !this.props.splitView && !this.props.hideLineNumbers && (React.createElement(\"td\", { onClick: additionalLineNumber &&\n                        this.onLineNumberClickProxy(additionalLineNumberTemplate), className: (0, classnames_1.default)(this.styles.gutter, {\n                        [this.styles.emptyGutter]: !additionalLineNumber,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedGutter]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.lineNumber }, additionalLineNumber))),\n                this.props.renderGutter\n                    ? this.props.renderGutter({\n                        lineNumber,\n                        type,\n                        prefix,\n                        value,\n                        additionalLineNumber,\n                        additionalPrefix,\n                        styles: this.styles,\n                    })\n                    : null,\n                React.createElement(\"td\", { className: (0, classnames_1.default)(this.styles.marker, {\n                        [this.styles.emptyLine]: !content,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedLine]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", null,\n                        added && '+',\n                        removed && '-')),\n                React.createElement(\"td\", { className: (0, classnames_1.default)(this.styles.content, {\n                        [this.styles.emptyLine]: !content,\n                        [this.styles.diffAdded]: added,\n                        [this.styles.diffRemoved]: removed,\n                        [this.styles.diffChanged]: changed,\n                        [this.styles.highlightedLine]: highlightLine,\n                    }) },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, content))));\n        };\n        /**\n         * Generates lines for split view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the left pane of the split view.\n         * @param obj.right Life diff information for the right pane of the split view.\n         * @param index React key for the lines.\n         */\n        this.renderSplitView = ({ left, right }, index) => {\n            return (React.createElement(\"tr\", { key: index, className: this.styles.line },\n                this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value),\n                this.renderLine(right.lineNumber, right.type, LineNumberPrefix.RIGHT, right.value)));\n        };\n        /**\n         * Generates lines for inline view.\n         *\n         * @param obj Line diff information.\n         * @param obj.left Life diff information for the added section of the inline view.\n         * @param obj.right Life diff information for the removed section of the inline view.\n         * @param index React key for the lines.\n         */\n        this.renderInlineView = ({ left, right }, index) => {\n            let content;\n            if (left.type === compute_lines_1.DiffType.REMOVED && right.type === compute_lines_1.DiffType.ADDED) {\n                return (React.createElement(React.Fragment, { key: index },\n                    React.createElement(\"tr\", { className: this.styles.line }, this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null)),\n                    React.createElement(\"tr\", { className: this.styles.line }, this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber))));\n            }\n            if (left.type === compute_lines_1.DiffType.REMOVED) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, null);\n            }\n            if (left.type === compute_lines_1.DiffType.DEFAULT) {\n                content = this.renderLine(left.lineNumber, left.type, LineNumberPrefix.LEFT, left.value, right.lineNumber, LineNumberPrefix.RIGHT);\n            }\n            if (right.type === compute_lines_1.DiffType.ADDED) {\n                content = this.renderLine(null, right.type, LineNumberPrefix.RIGHT, right.value, right.lineNumber);\n            }\n            return (React.createElement(\"tr\", { key: index, className: this.styles.line }, content));\n        };\n        /**\n         * Returns a function with clicked block number in the closure.\n         *\n         * @param id Cold fold block id.\n         */\n        this.onBlockClickProxy = (id) => () => this.onBlockExpand(id);\n        /**\n         * Generates cold fold block. It also uses the custom message renderer when available to show\n         * cold fold messages.\n         *\n         * @param num Number of skipped lines between two blocks.\n         * @param blockNumber Code fold block id.\n         * @param leftBlockLineNumber First left line number after the current code fold block.\n         * @param rightBlockLineNumber First right line number after the current code fold block.\n         */\n        this.renderSkippedLineIndicator = (num, blockNumber, leftBlockLineNumber, rightBlockLineNumber) => {\n            const { hideLineNumbers, splitView } = this.props;\n            const message = this.props.codeFoldMessageRenderer ? (this.props.codeFoldMessageRenderer(num, leftBlockLineNumber, rightBlockLineNumber)) : (React.createElement(\"pre\", { className: this.styles.codeFoldContent },\n                \"Expand \",\n                num,\n                \" lines ...\"));\n            const content = (React.createElement(\"td\", null,\n                React.createElement(\"a\", { onClick: this.onBlockClickProxy(blockNumber), tabIndex: 0 }, message)));\n            const isUnifiedViewWithoutLineNumbers = !splitView && !hideLineNumbers;\n            return (React.createElement(\"tr\", { key: `${leftBlockLineNumber}-${rightBlockLineNumber}`, className: this.styles.codeFold },\n                !hideLineNumbers && React.createElement(\"td\", { className: this.styles.codeFoldGutter }),\n                this.props.renderGutter ? (React.createElement(\"td\", { className: this.styles.codeFoldGutter })) : null,\n                React.createElement(\"td\", { className: (0, classnames_1.default)({\n                        [this.styles.codeFoldGutter]: isUnifiedViewWithoutLineNumbers,\n                    }) }),\n                isUnifiedViewWithoutLineNumbers ? (React.createElement(React.Fragment, null,\n                    React.createElement(\"td\", null),\n                    content)) : (React.createElement(React.Fragment, null,\n                    content,\n                    this.props.renderGutter ? React.createElement(\"td\", null) : null,\n                    React.createElement(\"td\", null))),\n                React.createElement(\"td\", null),\n                React.createElement(\"td\", null)));\n        };\n        /**\n         * Generates the entire diff view.\n         */\n        this.renderDiff = () => {\n            const { oldValue, newValue, splitView, disableWordDiff, compareMethod, linesOffset, } = this.props;\n            const { lineInformation, diffLines } = (0, compute_lines_1.computeLineInformation)(oldValue, newValue, disableWordDiff, compareMethod, linesOffset);\n            const extraLines = this.props.extraLinesSurroundingDiff < 0\n                ? 0\n                : this.props.extraLinesSurroundingDiff;\n            let skippedLines = [];\n            return lineInformation.map((line, i) => {\n                const diffBlockStart = diffLines[0];\n                const currentPosition = diffBlockStart - i;\n                if (this.props.showDiffOnly) {\n                    if (currentPosition === -extraLines) {\n                        skippedLines = [];\n                        diffLines.shift();\n                    }\n                    if (line.left.type === compute_lines_1.DiffType.DEFAULT &&\n                        (currentPosition > extraLines ||\n                            typeof diffBlockStart === 'undefined') &&\n                        !this.state.expandedBlocks.includes(diffBlockStart)) {\n                        skippedLines.push(i + 1);\n                        // show skipped line indicator only if there is more than one line to hide\n                        if (i === lineInformation.length - 1 && skippedLines.length > 1) {\n                            return this.renderSkippedLineIndicator(skippedLines.length, diffBlockStart, line.left.lineNumber, line.right.lineNumber);\n                            // if we are trying to hide the last line, just show it\n                        }\n                        else if (i < lineInformation.length - 1) {\n                            return null;\n                        }\n                    }\n                }\n                const diffNodes = splitView\n                    ? this.renderSplitView(line, i)\n                    : this.renderInlineView(line, i);\n                if (currentPosition === extraLines && skippedLines.length > 0) {\n                    const { length } = skippedLines;\n                    skippedLines = [];\n                    return (React.createElement(React.Fragment, { key: i },\n                        this.renderSkippedLineIndicator(length, diffBlockStart, line.left.lineNumber, line.right.lineNumber),\n                        diffNodes));\n                }\n                return diffNodes;\n            });\n        };\n        this.render = () => {\n            const { oldValue, newValue, useDarkTheme, leftTitle, rightTitle, splitView, hideLineNumbers, } = this.props;\n            if (this.props.compareMethod !== compute_lines_1.DiffMethod.JSON) {\n                if (typeof oldValue !== 'string' || typeof newValue !== 'string') {\n                    throw Error('\"oldValue\" and \"newValue\" should be strings');\n                }\n            }\n            this.styles = this.computeStyles(this.props.styles, useDarkTheme);\n            const nodes = this.renderDiff();\n            const colSpanOnSplitView = hideLineNumbers ? 2 : 3;\n            const colSpanOnInlineView = hideLineNumbers ? 2 : 4;\n            let columnExtension = this.props.renderGutter ? 1 : 0;\n            const title = (leftTitle || rightTitle) && (React.createElement(\"tr\", null,\n                React.createElement(\"td\", { colSpan: (splitView ? colSpanOnSplitView : colSpanOnInlineView) +\n                        columnExtension, className: this.styles.titleBlock },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, leftTitle)),\n                splitView && (React.createElement(\"td\", { colSpan: colSpanOnSplitView + columnExtension, className: this.styles.titleBlock },\n                    React.createElement(\"pre\", { className: this.styles.contentText }, rightTitle)))));\n            return (React.createElement(\"table\", { className: (0, classnames_1.default)(this.styles.diffContainer, {\n                    [this.styles.splitView]: splitView,\n                }) },\n                React.createElement(\"tbody\", null,\n                    title,\n                    nodes)));\n        };\n        this.state = {\n            expandedBlocks: [],\n        };\n    }\n}\nDiffViewer.defaultProps = {\n    oldValue: '',\n    newValue: '',\n    splitView: true,\n    highlightLines: [],\n    disableWordDiff: false,\n    compareMethod: compute_lines_1.DiffMethod.CHARS,\n    styles: {},\n    hideLineNumbers: false,\n    extraLinesSurroundingDiff: 3,\n    showDiffOnly: true,\n    useDarkTheme: false,\n    linesOffset: 0,\n};\nDiffViewer.propTypes = {\n    oldValue: PropTypes.any.isRequired,\n    newValue: PropTypes.any.isRequired,\n    splitView: PropTypes.bool,\n    disableWordDiff: PropTypes.bool,\n    compareMethod: PropTypes.oneOf(Object.values(compute_lines_1.DiffMethod)),\n    renderContent: PropTypes.func,\n    renderGutter: PropTypes.func,\n    onLineNumberClick: PropTypes.func,\n    extraLinesSurroundingDiff: PropTypes.number,\n    styles: PropTypes.object,\n    hideLineNumbers: PropTypes.bool,\n    showDiffOnly: PropTypes.bool,\n    highlightLines: PropTypes.arrayOf(PropTypes.string),\n    leftTitle: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    rightTitle: PropTypes.oneOfType([PropTypes.string, PropTypes.element]),\n    linesOffset: PropTypes.number,\n};\nexports[\"default\"] = DiffViewer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3VwZXJzZXQvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9pbmRleC5qcz9lYWNmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EaWZmTWV0aG9kID0gZXhwb3J0cy5MaW5lTnVtYmVyUHJlZml4ID0gdm9pZCAwO1xuY29uc3QgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XG5jb25zdCBQcm9wVHlwZXMgPSByZXF1aXJlKFwicHJvcC10eXBlc1wiKTtcbmNvbnN0IGNsYXNzbmFtZXNfMSA9IHJlcXVpcmUoXCJjbGFzc25hbWVzXCIpO1xuY29uc3QgY29tcHV0ZV9saW5lc18xID0gcmVxdWlyZShcIi4vY29tcHV0ZS1saW5lc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRpZmZNZXRob2RcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbXB1dGVfbGluZXNfMS5EaWZmTWV0aG9kOyB9IH0pO1xuY29uc3Qgc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9zdHlsZXNcIik7XG5jb25zdCBtID0gcmVxdWlyZSgnbWVtb2l6ZS1vbmUnKTtcbmNvbnN0IG1lbW9pemUgPSBtLmRlZmF1bHQgfHwgbTtcbnZhciBMaW5lTnVtYmVyUHJlZml4O1xuKGZ1bmN0aW9uIChMaW5lTnVtYmVyUHJlZml4KSB7XG4gICAgTGluZU51bWJlclByZWZpeFtcIkxFRlRcIl0gPSBcIkxcIjtcbiAgICBMaW5lTnVtYmVyUHJlZml4W1wiUklHSFRcIl0gPSBcIlJcIjtcbn0pKExpbmVOdW1iZXJQcmVmaXggPSBleHBvcnRzLkxpbmVOdW1iZXJQcmVmaXggfHwgKGV4cG9ydHMuTGluZU51bWJlclByZWZpeCA9IHt9KSk7XG5jbGFzcyBEaWZmVmlld2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNldHMgY29kZSBibG9jayBleHBhbmQgdG8gdGhlIGluaXRpYWwgc3RhZ2UuIFdpbGwgYmUgZXhwb3NlZCB0byB0aGUgcGFyZW50IGNvbXBvbmVudCB2aWFcbiAgICAgICAgICogcmVmcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzZXRDb2RlQmxvY2tzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXhwYW5kZWRCbG9ja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZEJsb2NrczogW10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQdXNoZXMgdGhlIHRhcmdldCBleHBhbmRlZCBjb2RlIGJsb2NrIHRvIHRoZSBzdGF0ZS4gRHVyaW5nIHRoZSByZS1yZW5kZXIsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgaXMgdXNlZCB0byBleHBhbmQvZm9sZCB1bm1vZGlmaWVkIGNvZGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmxvY2tFeHBhbmQgPSAoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc3RhdGUuZXhwYW5kZWRCbG9ja3Muc2xpY2UoKTtcbiAgICAgICAgICAgIHByZXZTdGF0ZS5wdXNoKGlkKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkQmxvY2tzOiBwcmV2U3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGVzIGZpbmFsIHN0eWxlcyBmb3IgdGhlIGRpZmYgdmlld2VyLiBJdCBjb21iaW5lcyB0aGUgZGVmYXVsdCBzdHlsZXMgd2l0aCB0aGUgdXNlclxuICAgICAgICAgKiBzdXBwbGllZCBvdmVycmlkZXMuIFRoZSBjb21wdXRlZCBzdHlsZXMgYXJlIGNhY2hlZCB3aXRoIHBlcmZvcm1hbmNlIGluIG1pbmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHlsZXMgVXNlciBzdXBwbGllZCBzdHlsZSBvdmVycmlkZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXB1dGVTdHlsZXMgPSBtZW1vaXplKHN0eWxlc18xLmRlZmF1bHQpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHdpdGggY2xpY2tlZCBsaW5lIG51bWJlciBpbiB0aGUgY2xvc3VyZS4gUmV0dXJucyBhbiBuby1vcCBmdW5jdGlvbiB3aGVuIG5vXG4gICAgICAgICAqIG9uTGluZU51bWJlckNsaWNrIGhhbmRsZXIgaXMgc3VwcGxpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBpZCBMaW5lIGlkIG9mIGEgbGluZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25MaW5lTnVtYmVyQ2xpY2tQcm94eSA9IChpZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25MaW5lTnVtYmVyQ2xpY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGUpID0+IHRoaXMucHJvcHMub25MaW5lTnVtYmVyQ2xpY2soaWQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgb3ZlciB0aGUgd29yZCBkaWZmIGFuZCBjb25zdHJ1Y3RzIHRoZSByZXF1aXJlZCBSZWFjdCBlbGVtZW50cyB0byBzaG93IHdvcmQgZGlmZi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpZmZBcnJheSBXb3JkIGRpZmYgaW5mb3JtYXRpb24gZGVyaXZlZCBmcm9tIGxpbmUgaW5mb3JtYXRpb24uXG4gICAgICAgICAqIEBwYXJhbSByZW5kZXJlciBPcHRpb25hbCByZW5kZXJlciB0byBmb3JtYXQgZGlmZiB3b3Jkcy4gVXNlZnVsIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJXb3JkRGlmZiA9IChkaWZmQXJyYXksIHJlbmRlcmVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZkFycmF5Lm1hcCgod29yZERpZmYsIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsga2V5OiBpLCBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkodGhpcy5zdHlsZXMud29yZERpZmYsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy53b3JkQWRkZWRdOiB3b3JkRGlmZi50eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuQURERUQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMud29yZFJlbW92ZWRdOiB3b3JkRGlmZi50eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuUkVNT1ZFRCxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSwgcmVuZGVyZXIgPyByZW5kZXJlcih3b3JkRGlmZi52YWx1ZSkgOiB3b3JkRGlmZi52YWx1ZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIG92ZXIgdGhlIGxpbmUgZGlmZiBhbmQgY29uc3RydWN0cyB0aGUgcmVxdWlyZWQgcmVhY3QgZWxlbWVudHMgdG8gc2hvdyBsaW5lIGRpZmYuIEl0IGNhbGxzXG4gICAgICAgICAqIHJlbmRlcldvcmREaWZmIHdoZW4gZW5jb3VudGVyaW5nIHdvcmQgZGlmZi4gVGhpcyB0YWtlcyBjYXJlIG9mIGJvdGggaW5saW5lIGFuZCBzcGxpdCB2aWV3IGxpbmVcbiAgICAgICAgICogcmVuZGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxpbmVOdW1iZXIgTGluZSBudW1iZXIgb2YgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICogQHBhcmFtIHR5cGUgVHlwZSBvZiBkaWZmIG9mIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAqIEBwYXJhbSBwcmVmaXggVW5pcXVlIGlkIHRvIHByZWZpeCB3aXRoIHRoZSBsaW5lIG51bWJlcnMuXG4gICAgICAgICAqIEBwYXJhbSB2YWx1ZSBDb250ZW50IG9mIHRoZSBsaW5lLiBJdCBjYW4gYmUgYSBzdHJpbmcgb3IgYSB3b3JkIGRpZmYgYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsTGluZU51bWJlciBBZGRpdGlvbmFsIGxpbmUgbnVtYmVyIHRvIGJlIHNob3duLiBVc2VmdWwgZm9yIHJlbmRlcmluZyBpbmxpbmVcbiAgICAgICAgICogIGRpZmYgdmlldy4gUmlnaHQgbGluZSBudW1iZXIgd2lsbCBiZSBwYXNzZWQgYXMgYWRkaXRpb25hbExpbmVOdW1iZXIuXG4gICAgICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsUHJlZml4IFNpbWlsYXIgdG8gcHJlZml4IGJ1dCBmb3IgYWRkaXRpb25hbCBsaW5lIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyTGluZSA9IChsaW5lTnVtYmVyLCB0eXBlLCBwcmVmaXgsIHZhbHVlLCBhZGRpdGlvbmFsTGluZU51bWJlciwgYWRkaXRpb25hbFByZWZpeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGluZU51bWJlclRlbXBsYXRlID0gYCR7cHJlZml4fS0ke2xpbmVOdW1iZXJ9YDtcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxMaW5lTnVtYmVyVGVtcGxhdGUgPSBgJHthZGRpdGlvbmFsUHJlZml4fS0ke2FkZGl0aW9uYWxMaW5lTnVtYmVyfWA7XG4gICAgICAgICAgICBjb25zdCBoaWdobGlnaHRMaW5lID0gdGhpcy5wcm9wcy5oaWdobGlnaHRMaW5lcy5pbmNsdWRlcyhsaW5lTnVtYmVyVGVtcGxhdGUpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5oaWdobGlnaHRMaW5lcy5pbmNsdWRlcyhhZGRpdGlvbmFsTGluZU51bWJlclRlbXBsYXRlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkID0gdHlwZSA9PT0gY29tcHV0ZV9saW5lc18xLkRpZmZUeXBlLkFEREVEO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVEO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5DSEFOR0VEO1xuICAgICAgICAgICAgbGV0IGNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZW5kZXJXb3JkRGlmZih2YWx1ZSwgdGhpcy5wcm9wcy5yZW5kZXJDb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMucmVuZGVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLnByb3BzLnJlbmRlckNvbnRlbnQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICF0aGlzLnByb3BzLmhpZGVMaW5lTnVtYmVycyAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgb25DbGljazogbGluZU51bWJlciAmJiB0aGlzLm9uTGluZU51bWJlckNsaWNrUHJveHkobGluZU51bWJlclRlbXBsYXRlKSwgY2xhc3NOYW1lOiAoMCwgY2xhc3NuYW1lc18xLmRlZmF1bHQpKHRoaXMuc3R5bGVzLmd1dHRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmVtcHR5R3V0dGVyXTogIWxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkFkZGVkXTogYWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZlJlbW92ZWRdOiByZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZDaGFuZ2VkXTogY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5oaWdobGlnaHRlZEd1dHRlcl06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmVOdW1iZXIgfSwgbGluZU51bWJlcikpKSxcbiAgICAgICAgICAgICAgICAhdGhpcy5wcm9wcy5zcGxpdFZpZXcgJiYgIXRoaXMucHJvcHMuaGlkZUxpbmVOdW1iZXJzICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBvbkNsaWNrOiBhZGRpdGlvbmFsTGluZU51bWJlciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxpbmVOdW1iZXJDbGlja1Byb3h5KGFkZGl0aW9uYWxMaW5lTnVtYmVyVGVtcGxhdGUpLCBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkodGhpcy5zdHlsZXMuZ3V0dGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZW1wdHlHdXR0ZXJdOiAhYWRkaXRpb25hbExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkFkZGVkXTogYWRkZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZlJlbW92ZWRdOiByZW1vdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmRpZmZDaGFuZ2VkXTogY2hhbmdlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5oaWdobGlnaHRlZEd1dHRlcl06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmVOdW1iZXIgfSwgYWRkaXRpb25hbExpbmVOdW1iZXIpKSksXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5yZW5kZXJHdXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLnJlbmRlckd1dHRlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh0aGlzLnN0eWxlcy5tYXJrZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5lbXB0eUxpbmVdOiAhY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQWRkZWRdOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmUmVtb3ZlZF06IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkNoYW5nZWRdOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmhpZ2hsaWdodGVkTGluZV06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkICYmICcrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgJiYgJy0nKSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIHsgY2xhc3NOYW1lOiAoMCwgY2xhc3NuYW1lc18xLmRlZmF1bHQpKHRoaXMuc3R5bGVzLmNvbnRlbnQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5lbXB0eUxpbmVdOiAhY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmQWRkZWRdOiBhZGRlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5kaWZmUmVtb3ZlZF06IHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBbdGhpcy5zdHlsZXMuZGlmZkNoYW5nZWRdOiBjaGFuZ2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmhpZ2hsaWdodGVkTGluZV06IGhpZ2hsaWdodExpbmUsXG4gICAgICAgICAgICAgICAgICAgIH0pIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvbnRlbnRUZXh0IH0sIGNvbnRlbnQpKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhdGVzIGxpbmVzIGZvciBzcGxpdCB2aWV3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JqIExpbmUgZGlmZiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHBhcmFtIG9iai5sZWZ0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIGxlZnQgcGFuZSBvZiB0aGUgc3BsaXQgdmlldy5cbiAgICAgICAgICogQHBhcmFtIG9iai5yaWdodCBMaWZlIGRpZmYgaW5mb3JtYXRpb24gZm9yIHRoZSByaWdodCBwYW5lIG9mIHRoZSBzcGxpdCB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggUmVhY3Qga2V5IGZvciB0aGUgbGluZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlclNwbGl0VmlldyA9ICh7IGxlZnQsIHJpZ2h0IH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogaW5kZXgsIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZSB9LFxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlKSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpbmUocmlnaHQubGluZU51bWJlciwgcmlnaHQudHlwZSwgTGluZU51bWJlclByZWZpeC5SSUdIVCwgcmlnaHQudmFsdWUpKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZXMgbGluZXMgZm9yIGlubGluZSB2aWV3LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gb2JqIExpbmUgZGlmZiBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogQHBhcmFtIG9iai5sZWZ0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkZGVkIHNlY3Rpb24gb2YgdGhlIGlubGluZSB2aWV3LlxuICAgICAgICAgKiBAcGFyYW0gb2JqLnJpZ2h0IExpZmUgZGlmZiBpbmZvcm1hdGlvbiBmb3IgdGhlIHJlbW92ZWQgc2VjdGlvbiBvZiB0aGUgaW5saW5lIHZpZXcuXG4gICAgICAgICAqIEBwYXJhbSBpbmRleCBSZWFjdCBrZXkgZm9yIHRoZSBsaW5lcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVySW5saW5lVmlldyA9ICh7IGxlZnQsIHJpZ2h0IH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVEICYmIHJpZ2h0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5BRERFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgeyBrZXk6IGluZGV4IH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMubGluZSB9LCB0aGlzLnJlbmRlckxpbmUobGVmdC5saW5lTnVtYmVyLCBsZWZ0LnR5cGUsIExpbmVOdW1iZXJQcmVmaXguTEVGVCwgbGVmdC52YWx1ZSwgbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmxpbmUgfSwgdGhpcy5yZW5kZXJMaW5lKG51bGwsIHJpZ2h0LnR5cGUsIExpbmVOdW1iZXJQcmVmaXguUklHSFQsIHJpZ2h0LnZhbHVlLCByaWdodC5saW5lTnVtYmVyKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5SRU1PVkVEKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5ERUZBVUxUKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMucmVuZGVyTGluZShsZWZ0LmxpbmVOdW1iZXIsIGxlZnQudHlwZSwgTGluZU51bWJlclByZWZpeC5MRUZULCBsZWZ0LnZhbHVlLCByaWdodC5saW5lTnVtYmVyLCBMaW5lTnVtYmVyUHJlZml4LlJJR0hUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodC50eXBlID09PSBjb21wdXRlX2xpbmVzXzEuRGlmZlR5cGUuQURERUQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5yZW5kZXJMaW5lKG51bGwsIHJpZ2h0LnR5cGUsIExpbmVOdW1iZXJQcmVmaXguUklHSFQsIHJpZ2h0LnZhbHVlLCByaWdodC5saW5lTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRyXCIsIHsga2V5OiBpbmRleCwgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5saW5lIH0sIGNvbnRlbnQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB3aXRoIGNsaWNrZWQgYmxvY2sgbnVtYmVyIGluIHRoZSBjbG9zdXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaWQgQ29sZCBmb2xkIGJsb2NrIGlkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkJsb2NrQ2xpY2tQcm94eSA9IChpZCkgPT4gKCkgPT4gdGhpcy5vbkJsb2NrRXhwYW5kKGlkKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBjb2xkIGZvbGQgYmxvY2suIEl0IGFsc28gdXNlcyB0aGUgY3VzdG9tIG1lc3NhZ2UgcmVuZGVyZXIgd2hlbiBhdmFpbGFibGUgdG8gc2hvd1xuICAgICAgICAgKiBjb2xkIGZvbGQgbWVzc2FnZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBudW0gTnVtYmVyIG9mIHNraXBwZWQgbGluZXMgYmV0d2VlbiB0d28gYmxvY2tzLlxuICAgICAgICAgKiBAcGFyYW0gYmxvY2tOdW1iZXIgQ29kZSBmb2xkIGJsb2NrIGlkLlxuICAgICAgICAgKiBAcGFyYW0gbGVmdEJsb2NrTGluZU51bWJlciBGaXJzdCBsZWZ0IGxpbmUgbnVtYmVyIGFmdGVyIHRoZSBjdXJyZW50IGNvZGUgZm9sZCBibG9jay5cbiAgICAgICAgICogQHBhcmFtIHJpZ2h0QmxvY2tMaW5lTnVtYmVyIEZpcnN0IHJpZ2h0IGxpbmUgbnVtYmVyIGFmdGVyIHRoZSBjdXJyZW50IGNvZGUgZm9sZCBibG9jay5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyU2tpcHBlZExpbmVJbmRpY2F0b3IgPSAobnVtLCBibG9ja051bWJlciwgbGVmdEJsb2NrTGluZU51bWJlciwgcmlnaHRCbG9ja0xpbmVOdW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaGlkZUxpbmVOdW1iZXJzLCBzcGxpdFZpZXcgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5wcm9wcy5jb2RlRm9sZE1lc3NhZ2VSZW5kZXJlciA/ICh0aGlzLnByb3BzLmNvZGVGb2xkTWVzc2FnZVJlbmRlcmVyKG51bSwgbGVmdEJsb2NrTGluZU51bWJlciwgcmlnaHRCbG9ja0xpbmVOdW1iZXIpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5jb2RlRm9sZENvbnRlbnQgfSxcbiAgICAgICAgICAgICAgICBcIkV4cGFuZCBcIixcbiAgICAgICAgICAgICAgICBudW0sXG4gICAgICAgICAgICAgICAgXCIgbGluZXMgLi4uXCIpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcInRkXCIsIG51bGwsXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBvbkNsaWNrOiB0aGlzLm9uQmxvY2tDbGlja1Byb3h5KGJsb2NrTnVtYmVyKSwgdGFiSW5kZXg6IDAgfSwgbWVzc2FnZSkpKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVW5pZmllZFZpZXdXaXRob3V0TGluZU51bWJlcnMgPSAhc3BsaXRWaWV3ICYmICFoaWRlTGluZU51bWJlcnM7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogYCR7bGVmdEJsb2NrTGluZU51bWJlcn0tJHtyaWdodEJsb2NrTGluZU51bWJlcn1gLCBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvZGVGb2xkIH0sXG4gICAgICAgICAgICAgICAgIWhpZGVMaW5lTnVtYmVycyAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLmNvZGVGb2xkR3V0dGVyIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMucmVuZGVyR3V0dGVyID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29kZUZvbGRHdXR0ZXIgfSkpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjbGFzc05hbWU6ICgwLCBjbGFzc25hbWVzXzEuZGVmYXVsdCkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgW3RoaXMuc3R5bGVzLmNvZGVGb2xkR3V0dGVyXTogaXNVbmlmaWVkVmlld1dpdGhvdXRMaW5lTnVtYmVycyxcbiAgICAgICAgICAgICAgICAgICAgfSkgfSksXG4gICAgICAgICAgICAgICAgaXNVbmlmaWVkVmlld1dpdGhvdXRMaW5lTnVtYmVycyA/IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQpKSA6IChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLnJlbmRlckd1dHRlciA/IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSkpLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCBudWxsKSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgbnVsbCkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyB0aGUgZW50aXJlIGRpZmYgdmlldy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyRGlmZiA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb2xkVmFsdWUsIG5ld1ZhbHVlLCBzcGxpdFZpZXcsIGRpc2FibGVXb3JkRGlmZiwgY29tcGFyZU1ldGhvZCwgbGluZXNPZmZzZXQsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBsaW5lSW5mb3JtYXRpb24sIGRpZmZMaW5lcyB9ID0gKDAsIGNvbXB1dGVfbGluZXNfMS5jb21wdXRlTGluZUluZm9ybWF0aW9uKShvbGRWYWx1ZSwgbmV3VmFsdWUsIGRpc2FibGVXb3JkRGlmZiwgY29tcGFyZU1ldGhvZCwgbGluZXNPZmZzZXQpO1xuICAgICAgICAgICAgY29uc3QgZXh0cmFMaW5lcyA9IHRoaXMucHJvcHMuZXh0cmFMaW5lc1N1cnJvdW5kaW5nRGlmZiA8IDBcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IHRoaXMucHJvcHMuZXh0cmFMaW5lc1N1cnJvdW5kaW5nRGlmZjtcbiAgICAgICAgICAgIGxldCBza2lwcGVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lSW5mb3JtYXRpb24ubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZkJsb2NrU3RhcnQgPSBkaWZmTGluZXNbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFBvc2l0aW9uID0gZGlmZkJsb2NrU3RhcnQgLSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLnNob3dEaWZmT25seSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFBvc2l0aW9uID09PSAtZXh0cmFMaW5lcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZExpbmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBkaWZmTGluZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZWZ0LnR5cGUgPT09IGNvbXB1dGVfbGluZXNfMS5EaWZmVHlwZS5ERUZBVUxUICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY3VycmVudFBvc2l0aW9uID4gZXh0cmFMaW5lcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBkaWZmQmxvY2tTdGFydCA9PT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5zdGF0ZS5leHBhbmRlZEJsb2Nrcy5pbmNsdWRlcyhkaWZmQmxvY2tTdGFydCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXBwZWRMaW5lcy5wdXNoKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3cgc2tpcHBlZCBsaW5lIGluZGljYXRvciBvbmx5IGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgbGluZSB0byBoaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gbGluZUluZm9ybWF0aW9uLmxlbmd0aCAtIDEgJiYgc2tpcHBlZExpbmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJTa2lwcGVkTGluZUluZGljYXRvcihza2lwcGVkTGluZXMubGVuZ3RoLCBkaWZmQmxvY2tTdGFydCwgbGluZS5sZWZ0LmxpbmVOdW1iZXIsIGxpbmUucmlnaHQubGluZU51bWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIHRyeWluZyB0byBoaWRlIHRoZSBsYXN0IGxpbmUsIGp1c3Qgc2hvdyBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA8IGxpbmVJbmZvcm1hdGlvbi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZGlmZk5vZGVzID0gc3BsaXRWaWV3XG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5yZW5kZXJTcGxpdFZpZXcobGluZSwgaSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnJlbmRlcklubGluZVZpZXcobGluZSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRQb3NpdGlvbiA9PT0gZXh0cmFMaW5lcyAmJiBza2lwcGVkTGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gc2tpcHBlZExpbmVzO1xuICAgICAgICAgICAgICAgICAgICBza2lwcGVkTGluZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJTa2lwcGVkTGluZUluZGljYXRvcihsZW5ndGgsIGRpZmZCbG9ja1N0YXJ0LCBsaW5lLmxlZnQubGluZU51bWJlciwgbGluZS5yaWdodC5saW5lTnVtYmVyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpZmZOb2RlcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZk5vZGVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbGRWYWx1ZSwgbmV3VmFsdWUsIHVzZURhcmtUaGVtZSwgbGVmdFRpdGxlLCByaWdodFRpdGxlLCBzcGxpdFZpZXcsIGhpZGVMaW5lTnVtYmVycywgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5jb21wYXJlTWV0aG9kICE9PSBjb21wdXRlX2xpbmVzXzEuRGlmZk1ldGhvZC5KU09OKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1ZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignXCJvbGRWYWx1ZVwiIGFuZCBcIm5ld1ZhbHVlXCIgc2hvdWxkIGJlIHN0cmluZ3MnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0eWxlcyA9IHRoaXMuY29tcHV0ZVN0eWxlcyh0aGlzLnByb3BzLnN0eWxlcywgdXNlRGFya1RoZW1lKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5yZW5kZXJEaWZmKCk7XG4gICAgICAgICAgICBjb25zdCBjb2xTcGFuT25TcGxpdFZpZXcgPSBoaWRlTGluZU51bWJlcnMgPyAyIDogMztcbiAgICAgICAgICAgIGNvbnN0IGNvbFNwYW5PbklubGluZVZpZXcgPSBoaWRlTGluZU51bWJlcnMgPyAyIDogNDtcbiAgICAgICAgICAgIGxldCBjb2x1bW5FeHRlbnNpb24gPSB0aGlzLnByb3BzLnJlbmRlckd1dHRlciA/IDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgdGl0bGUgPSAobGVmdFRpdGxlIHx8IHJpZ2h0VGl0bGUpICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidHJcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiAoc3BsaXRWaWV3ID8gY29sU3Bhbk9uU3BsaXRWaWV3IDogY29sU3Bhbk9uSW5saW5lVmlldykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uRXh0ZW5zaW9uLCBjbGFzc05hbWU6IHRoaXMuc3R5bGVzLnRpdGxlQmxvY2sgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInByZVwiLCB7IGNsYXNzTmFtZTogdGhpcy5zdHlsZXMuY29udGVudFRleHQgfSwgbGVmdFRpdGxlKSksXG4gICAgICAgICAgICAgICAgc3BsaXRWaWV3ICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwidGRcIiwgeyBjb2xTcGFuOiBjb2xTcGFuT25TcGxpdFZpZXcgKyBjb2x1bW5FeHRlbnNpb24sIGNsYXNzTmFtZTogdGhpcy5zdHlsZXMudGl0bGVCbG9jayB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHsgY2xhc3NOYW1lOiB0aGlzLnN0eWxlcy5jb250ZW50VGV4dCB9LCByaWdodFRpdGxlKSkpKSk7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiLCB7IGNsYXNzTmFtZTogKDAsIGNsYXNzbmFtZXNfMS5kZWZhdWx0KSh0aGlzLnN0eWxlcy5kaWZmQ29udGFpbmVyLCB7XG4gICAgICAgICAgICAgICAgICAgIFt0aGlzLnN0eWxlcy5zcGxpdFZpZXddOiBzcGxpdFZpZXcsXG4gICAgICAgICAgICAgICAgfSkgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVzKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZXhwYW5kZWRCbG9ja3M6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbn1cbkRpZmZWaWV3ZXIuZGVmYXVsdFByb3BzID0ge1xuICAgIG9sZFZhbHVlOiAnJyxcbiAgICBuZXdWYWx1ZTogJycsXG4gICAgc3BsaXRWaWV3OiB0cnVlLFxuICAgIGhpZ2hsaWdodExpbmVzOiBbXSxcbiAgICBkaXNhYmxlV29yZERpZmY6IGZhbHNlLFxuICAgIGNvbXBhcmVNZXRob2Q6IGNvbXB1dGVfbGluZXNfMS5EaWZmTWV0aG9kLkNIQVJTLFxuICAgIHN0eWxlczoge30sXG4gICAgaGlkZUxpbmVOdW1iZXJzOiBmYWxzZSxcbiAgICBleHRyYUxpbmVzU3Vycm91bmRpbmdEaWZmOiAzLFxuICAgIHNob3dEaWZmT25seTogdHJ1ZSxcbiAgICB1c2VEYXJrVGhlbWU6IGZhbHNlLFxuICAgIGxpbmVzT2Zmc2V0OiAwLFxufTtcbkRpZmZWaWV3ZXIucHJvcFR5cGVzID0ge1xuICAgIG9sZFZhbHVlOiBQcm9wVHlwZXMuYW55LmlzUmVxdWlyZWQsXG4gICAgbmV3VmFsdWU6IFByb3BUeXBlcy5hbnkuaXNSZXF1aXJlZCxcbiAgICBzcGxpdFZpZXc6IFByb3BUeXBlcy5ib29sLFxuICAgIGRpc2FibGVXb3JkRGlmZjogUHJvcFR5cGVzLmJvb2wsXG4gICAgY29tcGFyZU1ldGhvZDogUHJvcFR5cGVzLm9uZU9mKE9iamVjdC52YWx1ZXMoY29tcHV0ZV9saW5lc18xLkRpZmZNZXRob2QpKSxcbiAgICByZW5kZXJDb250ZW50OiBQcm9wVHlwZXMuZnVuYyxcbiAgICByZW5kZXJHdXR0ZXI6IFByb3BUeXBlcy5mdW5jLFxuICAgIG9uTGluZU51bWJlckNsaWNrOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBleHRyYUxpbmVzU3Vycm91bmRpbmdEaWZmOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgIHN0eWxlczogUHJvcFR5cGVzLm9iamVjdCxcbiAgICBoaWRlTGluZU51bWJlcnM6IFByb3BUeXBlcy5ib29sLFxuICAgIHNob3dEaWZmT25seTogUHJvcFR5cGVzLmJvb2wsXG4gICAgaGlnaGxpZ2h0TGluZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICAgIGxlZnRUaXRsZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmVsZW1lbnRdKSxcbiAgICByaWdodFRpdGxlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuICAgIGxpbmVzT2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IERpZmZWaWV3ZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-diff-viewer-continued/lib/index.js\n");

/***/ }),

/***/ "./node_modules/react-diff-viewer-continued/lib/styles.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-diff-viewer-continued/lib/styles.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst emotion_1 = __webpack_require__(/*! emotion */ \"./node_modules/emotion/dist/emotion.esm.js\");\n// eslint-disable-next-line import/no-anonymous-default-export\nexports[\"default\"] = (styleOverride, useDarkTheme = false) => {\n    const { variables: overrideVariables = {} } = styleOverride, styles = __rest(styleOverride, [\"variables\"]);\n    const themeVariables = {\n        light: Object.assign({\n            diffViewerBackground: '#fff',\n            diffViewerColor: '#212529',\n            addedBackground: '#e6ffed',\n            addedColor: '#24292e',\n            removedBackground: '#ffeef0',\n            removedColor: '#24292e',\n            changedBackground: '#fffbdd',\n            wordAddedBackground: '#acf2bd',\n            wordRemovedBackground: '#fdb8c0',\n            addedGutterBackground: '#cdffd8',\n            removedGutterBackground: '#ffdce0',\n            gutterBackground: '#f7f7f7',\n            gutterBackgroundDark: '#f3f1f1',\n            highlightBackground: '#fffbdd',\n            highlightGutterBackground: '#fff5b1',\n            codeFoldGutterBackground: '#dbedff',\n            codeFoldBackground: '#f1f8ff',\n            emptyLineBackground: '#fafbfc',\n            gutterColor: '#212529',\n            addedGutterColor: '#212529',\n            removedGutterColor: '#212529',\n            codeFoldContentColor: '#212529',\n            diffViewerTitleBackground: '#fafbfc',\n            diffViewerTitleColor: '#212529',\n            diffViewerTitleBorderColor: '#eee',\n        }, (overrideVariables.light || {})),\n        dark: Object.assign({\n            diffViewerBackground: '#2e303c',\n            diffViewerColor: '#FFF',\n            addedBackground: '#044B53',\n            addedColor: 'white',\n            removedBackground: '#632F34',\n            removedColor: 'white',\n            changedBackground: '#3e302c',\n            wordAddedBackground: '#055d67',\n            wordRemovedBackground: '#7d383f',\n            addedGutterBackground: '#034148',\n            removedGutterBackground: '#632b30',\n            gutterBackground: '#2c2f3a',\n            gutterBackgroundDark: '#262933',\n            highlightBackground: '#2a3967',\n            highlightGutterBackground: '#2d4077',\n            codeFoldGutterBackground: '#21232b',\n            codeFoldBackground: '#262831',\n            emptyLineBackground: '#363946',\n            gutterColor: '#666c87',\n            addedGutterColor: '#8c8c8c',\n            removedGutterColor: '#8c8c8c',\n            codeFoldContentColor: '#656a8b',\n            diffViewerTitleBackground: '#2f323e',\n            diffViewerTitleColor: '#555a7b',\n            diffViewerTitleBorderColor: '#353846',\n        }, (overrideVariables.dark || {})),\n    };\n    const variables = useDarkTheme ? themeVariables.dark : themeVariables.light;\n    const content = (0, emotion_1.css)({\n        width: '100%',\n        label: 'content',\n    });\n    const splitView = (0, emotion_1.css)({\n        [`.${content}`]: {\n            width: '50%',\n        },\n        label: 'split-view',\n    });\n    const diffContainer = (0, emotion_1.css)({\n        width: '100%',\n        background: variables.diffViewerBackground,\n        pre: {\n            margin: 0,\n            whiteSpace: 'pre-wrap',\n            lineHeight: '25px',\n        },\n        label: 'diff-container',\n        borderCollapse: 'collapse',\n    });\n    const codeFoldContent = (0, emotion_1.css)({\n        color: variables.codeFoldContentColor,\n        label: 'code-fold-content',\n    });\n    const contentText = (0, emotion_1.css)({\n        color: variables.diffViewerColor,\n        label: 'content-text',\n    });\n    const titleBlock = (0, emotion_1.css)({\n        background: variables.diffViewerTitleBackground,\n        padding: 10,\n        borderBottom: `1px solid ${variables.diffViewerTitleBorderColor}`,\n        label: 'title-block',\n        ':last-child': {\n            borderLeft: `1px solid ${variables.diffViewerTitleBorderColor}`,\n        },\n        [`.${contentText}`]: {\n            color: variables.diffViewerTitleColor,\n        },\n    });\n    const lineNumber = (0, emotion_1.css)({\n        color: variables.gutterColor,\n        label: 'line-number',\n    });\n    const diffRemoved = (0, emotion_1.css)({\n        background: variables.removedBackground,\n        color: variables.removedColor,\n        pre: {\n            color: variables.removedColor,\n        },\n        [`.${lineNumber}`]: {\n            color: variables.removedGutterColor,\n        },\n        label: 'diff-removed',\n    });\n    const diffAdded = (0, emotion_1.css)({\n        background: variables.addedBackground,\n        color: variables.addedColor,\n        pre: {\n            color: variables.addedColor,\n        },\n        [`.${lineNumber}`]: {\n            color: variables.addedGutterColor,\n        },\n        label: 'diff-added',\n    });\n    const diffChanged = (0, emotion_1.css)({\n        background: variables.changedBackground,\n        [`.${lineNumber}`]: {\n            color: variables.gutterColor,\n        },\n        label: 'diff-changed',\n    });\n    const wordDiff = (0, emotion_1.css)({\n        padding: 2,\n        display: 'inline-flex',\n        borderRadius: 4,\n        wordBreak: 'break-all',\n        label: 'word-diff',\n    });\n    const wordAdded = (0, emotion_1.css)({\n        background: variables.wordAddedBackground,\n        label: 'word-added',\n    });\n    const wordRemoved = (0, emotion_1.css)({\n        background: variables.wordRemovedBackground,\n        label: 'word-removed',\n    });\n    const codeFoldGutter = (0, emotion_1.css)({\n        backgroundColor: variables.codeFoldGutterBackground,\n        label: 'code-fold-gutter',\n    });\n    const codeFold = (0, emotion_1.css)({\n        backgroundColor: variables.codeFoldBackground,\n        height: 40,\n        fontSize: 14,\n        fontWeight: 700,\n        label: 'code-fold',\n        a: {\n            textDecoration: 'underline !important',\n            cursor: 'pointer',\n            pre: {\n                display: 'inline',\n            },\n        },\n    });\n    const emptyLine = (0, emotion_1.css)({\n        backgroundColor: variables.emptyLineBackground,\n        label: 'empty-line',\n    });\n    const marker = (0, emotion_1.css)({\n        width: 25,\n        paddingLeft: 10,\n        paddingRight: 10,\n        userSelect: 'none',\n        label: 'marker',\n        [`&.${diffAdded}`]: {\n            pre: {\n                color: variables.addedColor,\n            },\n        },\n        [`&.${diffRemoved}`]: {\n            pre: {\n                color: variables.removedColor,\n            },\n        },\n    });\n    const highlightedLine = (0, emotion_1.css)({\n        background: variables.highlightBackground,\n        label: 'highlighted-line',\n        [`.${wordAdded}, .${wordRemoved}`]: {\n            backgroundColor: 'initial',\n        },\n    });\n    const highlightedGutter = (0, emotion_1.css)({\n        label: 'highlighted-gutter',\n    });\n    const gutter = (0, emotion_1.css)({\n        userSelect: 'none',\n        minWidth: 50,\n        padding: '0 10px',\n        whiteSpace: 'nowrap',\n        label: 'gutter',\n        textAlign: 'right',\n        background: variables.gutterBackground,\n        '&:hover': {\n            cursor: 'pointer',\n            background: variables.gutterBackgroundDark,\n            pre: {\n                opacity: 1,\n            },\n        },\n        pre: {\n            opacity: 0.5,\n        },\n        [`&.${diffAdded}`]: {\n            background: variables.addedGutterBackground,\n        },\n        [`&.${diffRemoved}`]: {\n            background: variables.removedGutterBackground,\n        },\n        [`&.${highlightedGutter}`]: {\n            background: variables.highlightGutterBackground,\n            '&:hover': {\n                background: variables.highlightGutterBackground,\n            },\n        },\n    });\n    const emptyGutter = (0, emotion_1.css)({\n        '&:hover': {\n            background: variables.gutterBackground,\n            cursor: 'initial',\n        },\n        label: 'empty-gutter',\n    });\n    const line = (0, emotion_1.css)({\n        verticalAlign: 'baseline',\n        label: 'line',\n    });\n    const defaultStyles = {\n        diffContainer,\n        diffRemoved,\n        diffAdded,\n        diffChanged,\n        splitView,\n        marker,\n        highlightedGutter,\n        highlightedLine,\n        gutter,\n        line,\n        wordDiff,\n        wordAdded,\n        wordRemoved,\n        codeFoldGutter,\n        codeFold,\n        emptyGutter,\n        emptyLine,\n        lineNumber,\n        contentText,\n        content,\n        codeFoldContent,\n        titleBlock,\n    };\n    const computerOverrideStyles = Object.keys(styles).reduce((acc, key) => (Object.assign(Object.assign({}, acc), {\n        [key]: (0, emotion_1.css)(styles[key]),\n    })), {});\n    return Object.keys(defaultStyles).reduce((acc, key) => (Object.assign(Object.assign({}, acc), {\n        [key]: computerOverrideStyles[key]\n            ? (0, emotion_1.cx)(defaultStyles[key], computerOverrideStyles[key])\n            : defaultStyles[key],\n    })), {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtZGlmZi12aWV3ZXItY29udGludWVkL2xpYi9zdHlsZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3N1cGVyc2V0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZC9saWIvc3R5bGVzLmpzPzhhZDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlbW90aW9uXzEgPSByZXF1aXJlKFwiZW1vdGlvblwiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tYW5vbnltb3VzLWRlZmF1bHQtZXhwb3J0XG5leHBvcnRzLmRlZmF1bHQgPSAoc3R5bGVPdmVycmlkZSwgdXNlRGFya1RoZW1lID0gZmFsc2UpID0+IHtcbiAgICBjb25zdCB7IHZhcmlhYmxlczogb3ZlcnJpZGVWYXJpYWJsZXMgPSB7fSB9ID0gc3R5bGVPdmVycmlkZSwgc3R5bGVzID0gX19yZXN0KHN0eWxlT3ZlcnJpZGUsIFtcInZhcmlhYmxlc1wiXSk7XG4gICAgY29uc3QgdGhlbWVWYXJpYWJsZXMgPSB7XG4gICAgICAgIGxpZ2h0OiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJCYWNrZ3JvdW5kOiAnI2ZmZicsXG4gICAgICAgICAgICBkaWZmVmlld2VyQ29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIGFkZGVkQmFja2dyb3VuZDogJyNlNmZmZWQnLFxuICAgICAgICAgICAgYWRkZWRDb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgcmVtb3ZlZEJhY2tncm91bmQ6ICcjZmZlZWYwJyxcbiAgICAgICAgICAgIHJlbW92ZWRDb2xvcjogJyMyNDI5MmUnLFxuICAgICAgICAgICAgY2hhbmdlZEJhY2tncm91bmQ6ICcjZmZmYmRkJyxcbiAgICAgICAgICAgIHdvcmRBZGRlZEJhY2tncm91bmQ6ICcjYWNmMmJkJyxcbiAgICAgICAgICAgIHdvcmRSZW1vdmVkQmFja2dyb3VuZDogJyNmZGI4YzAnLFxuICAgICAgICAgICAgYWRkZWRHdXR0ZXJCYWNrZ3JvdW5kOiAnI2NkZmZkOCcsXG4gICAgICAgICAgICByZW1vdmVkR3V0dGVyQmFja2dyb3VuZDogJyNmZmRjZTAnLFxuICAgICAgICAgICAgZ3V0dGVyQmFja2dyb3VuZDogJyNmN2Y3ZjcnLFxuICAgICAgICAgICAgZ3V0dGVyQmFja2dyb3VuZERhcms6ICcjZjNmMWYxJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEJhY2tncm91bmQ6ICcjZmZmYmRkJyxcbiAgICAgICAgICAgIGhpZ2hsaWdodEd1dHRlckJhY2tncm91bmQ6ICcjZmZmNWIxJyxcbiAgICAgICAgICAgIGNvZGVGb2xkR3V0dGVyQmFja2dyb3VuZDogJyNkYmVkZmYnLFxuICAgICAgICAgICAgY29kZUZvbGRCYWNrZ3JvdW5kOiAnI2YxZjhmZicsXG4gICAgICAgICAgICBlbXB0eUxpbmVCYWNrZ3JvdW5kOiAnI2ZhZmJmYycsXG4gICAgICAgICAgICBndXR0ZXJDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgYWRkZWRHdXR0ZXJDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgcmVtb3ZlZEd1dHRlckNvbG9yOiAnIzIxMjUyOScsXG4gICAgICAgICAgICBjb2RlRm9sZENvbnRlbnRDb2xvcjogJyMyMTI1MjknLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQmFja2dyb3VuZDogJyNmYWZiZmMnLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQ29sb3I6ICcjMjEyNTI5JyxcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yOiAnI2VlZScsXG4gICAgICAgIH0sIChvdmVycmlkZVZhcmlhYmxlcy5saWdodCB8fCB7fSkpLFxuICAgICAgICBkYXJrOiBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGRpZmZWaWV3ZXJCYWNrZ3JvdW5kOiAnIzJlMzAzYycsXG4gICAgICAgICAgICBkaWZmVmlld2VyQ29sb3I6ICcjRkZGJyxcbiAgICAgICAgICAgIGFkZGVkQmFja2dyb3VuZDogJyMwNDRCNTMnLFxuICAgICAgICAgICAgYWRkZWRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIHJlbW92ZWRCYWNrZ3JvdW5kOiAnIzYzMkYzNCcsXG4gICAgICAgICAgICByZW1vdmVkQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBjaGFuZ2VkQmFja2dyb3VuZDogJyMzZTMwMmMnLFxuICAgICAgICAgICAgd29yZEFkZGVkQmFja2dyb3VuZDogJyMwNTVkNjcnLFxuICAgICAgICAgICAgd29yZFJlbW92ZWRCYWNrZ3JvdW5kOiAnIzdkMzgzZicsXG4gICAgICAgICAgICBhZGRlZEd1dHRlckJhY2tncm91bmQ6ICcjMDM0MTQ4JyxcbiAgICAgICAgICAgIHJlbW92ZWRHdXR0ZXJCYWNrZ3JvdW5kOiAnIzYzMmIzMCcsXG4gICAgICAgICAgICBndXR0ZXJCYWNrZ3JvdW5kOiAnIzJjMmYzYScsXG4gICAgICAgICAgICBndXR0ZXJCYWNrZ3JvdW5kRGFyazogJyMyNjI5MzMnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0QmFja2dyb3VuZDogJyMyYTM5NjcnLFxuICAgICAgICAgICAgaGlnaGxpZ2h0R3V0dGVyQmFja2dyb3VuZDogJyMyZDQwNzcnLFxuICAgICAgICAgICAgY29kZUZvbGRHdXR0ZXJCYWNrZ3JvdW5kOiAnIzIxMjMyYicsXG4gICAgICAgICAgICBjb2RlRm9sZEJhY2tncm91bmQ6ICcjMjYyODMxJyxcbiAgICAgICAgICAgIGVtcHR5TGluZUJhY2tncm91bmQ6ICcjMzYzOTQ2JyxcbiAgICAgICAgICAgIGd1dHRlckNvbG9yOiAnIzY2NmM4NycsXG4gICAgICAgICAgICBhZGRlZEd1dHRlckNvbG9yOiAnIzhjOGM4YycsXG4gICAgICAgICAgICByZW1vdmVkR3V0dGVyQ29sb3I6ICcjOGM4YzhjJyxcbiAgICAgICAgICAgIGNvZGVGb2xkQ29udGVudENvbG9yOiAnIzY1NmE4YicsXG4gICAgICAgICAgICBkaWZmVmlld2VyVGl0bGVCYWNrZ3JvdW5kOiAnIzJmMzIzZScsXG4gICAgICAgICAgICBkaWZmVmlld2VyVGl0bGVDb2xvcjogJyM1NTVhN2InLFxuICAgICAgICAgICAgZGlmZlZpZXdlclRpdGxlQm9yZGVyQ29sb3I6ICcjMzUzODQ2JyxcbiAgICAgICAgfSwgKG92ZXJyaWRlVmFyaWFibGVzLmRhcmsgfHwge30pKSxcbiAgICB9O1xuICAgIGNvbnN0IHZhcmlhYmxlcyA9IHVzZURhcmtUaGVtZSA/IHRoZW1lVmFyaWFibGVzLmRhcmsgOiB0aGVtZVZhcmlhYmxlcy5saWdodDtcbiAgICBjb25zdCBjb250ZW50ID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbGFiZWw6ICdjb250ZW50JyxcbiAgICB9KTtcbiAgICBjb25zdCBzcGxpdFZpZXcgPSAoMCwgZW1vdGlvbl8xLmNzcykoe1xuICAgICAgICBbYC4ke2NvbnRlbnR9YF06IHtcbiAgICAgICAgICAgIHdpZHRoOiAnNTAlJyxcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6ICdzcGxpdC12aWV3JyxcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmQ29udGFpbmVyID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmRpZmZWaWV3ZXJCYWNrZ3JvdW5kLFxuICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMjVweCcsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZGlmZi1jb250YWluZXInLFxuICAgICAgICBib3JkZXJDb2xsYXBzZTogJ2NvbGxhcHNlJyxcbiAgICB9KTtcbiAgICBjb25zdCBjb2RlRm9sZENvbnRlbnQgPSAoMCwgZW1vdGlvbl8xLmNzcykoe1xuICAgICAgICBjb2xvcjogdmFyaWFibGVzLmNvZGVGb2xkQ29udGVudENvbG9yLFxuICAgICAgICBsYWJlbDogJ2NvZGUtZm9sZC1jb250ZW50JyxcbiAgICB9KTtcbiAgICBjb25zdCBjb250ZW50VGV4dCA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZGlmZlZpZXdlckNvbG9yLFxuICAgICAgICBsYWJlbDogJ2NvbnRlbnQtdGV4dCcsXG4gICAgfSk7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5kaWZmVmlld2VyVGl0bGVCYWNrZ3JvdW5kLFxuICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgYm9yZGVyQm90dG9tOiBgMXB4IHNvbGlkICR7dmFyaWFibGVzLmRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yfWAsXG4gICAgICAgIGxhYmVsOiAndGl0bGUtYmxvY2snLFxuICAgICAgICAnOmxhc3QtY2hpbGQnOiB7XG4gICAgICAgICAgICBib3JkZXJMZWZ0OiBgMXB4IHNvbGlkICR7dmFyaWFibGVzLmRpZmZWaWV3ZXJUaXRsZUJvcmRlckNvbG9yfWAsXG4gICAgICAgIH0sXG4gICAgICAgIFtgLiR7Y29udGVudFRleHR9YF06IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZGlmZlZpZXdlclRpdGxlQ29sb3IsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbGluZU51bWJlciA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZ3V0dGVyQ29sb3IsXG4gICAgICAgIGxhYmVsOiAnbGluZS1udW1iZXInLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZSZW1vdmVkID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLnJlbW92ZWRCYWNrZ3JvdW5kLFxuICAgICAgICBjb2xvcjogdmFyaWFibGVzLnJlbW92ZWRDb2xvcixcbiAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLnJlbW92ZWRDb2xvcixcbiAgICAgICAgfSxcbiAgICAgICAgW2AuJHtsaW5lTnVtYmVyfWBdOiB7XG4gICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLnJlbW92ZWRHdXR0ZXJDb2xvcixcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6ICdkaWZmLXJlbW92ZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZBZGRlZCA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5hZGRlZEJhY2tncm91bmQsXG4gICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuYWRkZWRDb2xvcixcbiAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLmFkZGVkQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIFtgLiR7bGluZU51bWJlcn1gXToge1xuICAgICAgICAgICAgY29sb3I6IHZhcmlhYmxlcy5hZGRlZEd1dHRlckNvbG9yLFxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJ2RpZmYtYWRkZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpZmZDaGFuZ2VkID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmNoYW5nZWRCYWNrZ3JvdW5kLFxuICAgICAgICBbYC4ke2xpbmVOdW1iZXJ9YF06IHtcbiAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuZ3V0dGVyQ29sb3IsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZGlmZi1jaGFuZ2VkJyxcbiAgICB9KTtcbiAgICBjb25zdCB3b3JkRGlmZiA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIHBhZGRpbmc6IDIsXG4gICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtZmxleCcsXG4gICAgICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAgICAgd29yZEJyZWFrOiAnYnJlYWstYWxsJyxcbiAgICAgICAgbGFiZWw6ICd3b3JkLWRpZmYnLFxuICAgIH0pO1xuICAgIGNvbnN0IHdvcmRBZGRlZCA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy53b3JkQWRkZWRCYWNrZ3JvdW5kLFxuICAgICAgICBsYWJlbDogJ3dvcmQtYWRkZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IHdvcmRSZW1vdmVkID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLndvcmRSZW1vdmVkQmFja2dyb3VuZCxcbiAgICAgICAgbGFiZWw6ICd3b3JkLXJlbW92ZWQnLFxuICAgIH0pO1xuICAgIGNvbnN0IGNvZGVGb2xkR3V0dGVyID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJpYWJsZXMuY29kZUZvbGRHdXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICBsYWJlbDogJ2NvZGUtZm9sZC1ndXR0ZXInLFxuICAgIH0pO1xuICAgIGNvbnN0IGNvZGVGb2xkID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YXJpYWJsZXMuY29kZUZvbGRCYWNrZ3JvdW5kLFxuICAgICAgICBoZWlnaHQ6IDQwLFxuICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgIGZvbnRXZWlnaHQ6IDcwMCxcbiAgICAgICAgbGFiZWw6ICdjb2RlLWZvbGQnLFxuICAgICAgICBhOiB7XG4gICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ3VuZGVybGluZSAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxuICAgICAgICAgICAgcHJlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGVtcHR5TGluZSA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFyaWFibGVzLmVtcHR5TGluZUJhY2tncm91bmQsXG4gICAgICAgIGxhYmVsOiAnZW1wdHktbGluZScsXG4gICAgfSk7XG4gICAgY29uc3QgbWFya2VyID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgd2lkdGg6IDI1LFxuICAgICAgICBwYWRkaW5nTGVmdDogMTAsXG4gICAgICAgIHBhZGRpbmdSaWdodDogMTAsXG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgbGFiZWw6ICdtYXJrZXInLFxuICAgICAgICBbYCYuJHtkaWZmQWRkZWR9YF06IHtcbiAgICAgICAgICAgIHByZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiB2YXJpYWJsZXMuYWRkZWRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgJi4ke2RpZmZSZW1vdmVkfWBdOiB7XG4gICAgICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogdmFyaWFibGVzLnJlbW92ZWRDb2xvcixcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWRMaW5lID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmhpZ2hsaWdodEJhY2tncm91bmQsXG4gICAgICAgIGxhYmVsOiAnaGlnaGxpZ2h0ZWQtbGluZScsXG4gICAgICAgIFtgLiR7d29yZEFkZGVkfSwgLiR7d29yZFJlbW92ZWR9YF06IHtcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2luaXRpYWwnLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkR3V0dGVyID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgbGFiZWw6ICdoaWdobGlnaHRlZC1ndXR0ZXInLFxuICAgIH0pO1xuICAgIGNvbnN0IGd1dHRlciA9ICgwLCBlbW90aW9uXzEuY3NzKSh7XG4gICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgbWluV2lkdGg6IDUwLFxuICAgICAgICBwYWRkaW5nOiAnMCAxMHB4JyxcbiAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCcsXG4gICAgICAgIGxhYmVsOiAnZ3V0dGVyJyxcbiAgICAgICAgdGV4dEFsaWduOiAncmlnaHQnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuZ3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgJyY6aG92ZXInOiB7XG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5ndXR0ZXJCYWNrZ3JvdW5kRGFyayxcbiAgICAgICAgICAgIHByZToge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcmU6IHtcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgfSxcbiAgICAgICAgW2AmLiR7ZGlmZkFkZGVkfWBdOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuYWRkZWRHdXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICB9LFxuICAgICAgICBbYCYuJHtkaWZmUmVtb3ZlZH1gXToge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLnJlbW92ZWRHdXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICB9LFxuICAgICAgICBbYCYuJHtoaWdobGlnaHRlZEd1dHRlcn1gXToge1xuICAgICAgICAgICAgYmFja2dyb3VuZDogdmFyaWFibGVzLmhpZ2hsaWdodEd1dHRlckJhY2tncm91bmQsXG4gICAgICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB2YXJpYWJsZXMuaGlnaGxpZ2h0R3V0dGVyQmFja2dyb3VuZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgZW1wdHlHdXR0ZXIgPSAoMCwgZW1vdGlvbl8xLmNzcykoe1xuICAgICAgICAnJjpob3Zlcic6IHtcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IHZhcmlhYmxlcy5ndXR0ZXJCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgY3Vyc29yOiAnaW5pdGlhbCcsXG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsOiAnZW1wdHktZ3V0dGVyJyxcbiAgICB9KTtcbiAgICBjb25zdCBsaW5lID0gKDAsIGVtb3Rpb25fMS5jc3MpKHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ2Jhc2VsaW5lJyxcbiAgICAgICAgbGFiZWw6ICdsaW5lJyxcbiAgICB9KTtcbiAgICBjb25zdCBkZWZhdWx0U3R5bGVzID0ge1xuICAgICAgICBkaWZmQ29udGFpbmVyLFxuICAgICAgICBkaWZmUmVtb3ZlZCxcbiAgICAgICAgZGlmZkFkZGVkLFxuICAgICAgICBkaWZmQ2hhbmdlZCxcbiAgICAgICAgc3BsaXRWaWV3LFxuICAgICAgICBtYXJrZXIsXG4gICAgICAgIGhpZ2hsaWdodGVkR3V0dGVyLFxuICAgICAgICBoaWdobGlnaHRlZExpbmUsXG4gICAgICAgIGd1dHRlcixcbiAgICAgICAgbGluZSxcbiAgICAgICAgd29yZERpZmYsXG4gICAgICAgIHdvcmRBZGRlZCxcbiAgICAgICAgd29yZFJlbW92ZWQsXG4gICAgICAgIGNvZGVGb2xkR3V0dGVyLFxuICAgICAgICBjb2RlRm9sZCxcbiAgICAgICAgZW1wdHlHdXR0ZXIsXG4gICAgICAgIGVtcHR5TGluZSxcbiAgICAgICAgbGluZU51bWJlcixcbiAgICAgICAgY29udGVudFRleHQsXG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGNvZGVGb2xkQ29udGVudCxcbiAgICAgICAgdGl0bGVCbG9jayxcbiAgICB9O1xuICAgIGNvbnN0IGNvbXB1dGVyT3ZlcnJpZGVTdHlsZXMgPSBPYmplY3Qua2V5cyhzdHlsZXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHtcbiAgICAgICAgW2tleV06ICgwLCBlbW90aW9uXzEuY3NzKShzdHlsZXNba2V5XSksXG4gICAgfSkpLCB7fSk7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRlZmF1bHRTdHlsZXMpLnJlZHVjZSgoYWNjLCBrZXkpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHtcbiAgICAgICAgW2tleV06IGNvbXB1dGVyT3ZlcnJpZGVTdHlsZXNba2V5XVxuICAgICAgICAgICAgPyAoMCwgZW1vdGlvbl8xLmN4KShkZWZhdWx0U3R5bGVzW2tleV0sIGNvbXB1dGVyT3ZlcnJpZGVTdHlsZXNba2V5XSlcbiAgICAgICAgICAgIDogZGVmYXVsdFN0eWxlc1trZXldLFxuICAgIH0pKSwge30pO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-diff-viewer-continued/lib/styles.js\n");

/***/ }),

/***/ "./node_modules/react-diff-viewer-continued/node_modules/diff/lib/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/react-diff-viewer-continued/node_modules/diff/lib/index.js ***!
  \*********************************************************************************/
/***/ (() => {

throw new Error("Module build failed: Error: ENOENT: no such file or directory, open '/app/superset-frontend/node_modules/react-diff-viewer-continued/node_modules/diff/lib/index.js'");

/***/ }),

/***/ "./node_modules/react-diff-viewer-continued/node_modules/memoize-one/dist/memoize-one.esm.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/react-diff-viewer-continued/node_modules/memoize-one/dist/memoize-one.esm.js ***!
  \***************************************************************************************************/
/***/ (() => {

throw new Error("Module build failed: Error: ENOENT: no such file or directory, open '/app/superset-frontend/node_modules/react-diff-viewer-continued/node_modules/memoize-one/dist/memoize-one.esm.js'");

/***/ }),

/***/ "./src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx":
/*!*****************************************************************************!*\
  !*** ./src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx ***!
  \*****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment */ \"./node_modules/moment/moment.js\");\n/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\n/* harmony import */ var react_diff_viewer_continued__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-diff-viewer-continued */ \"./node_modules/react-diff-viewer-continued/lib/index.js\");\n/* harmony import */ var react_intersection_observer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react-intersection-observer */ \"./node_modules/react-intersection-observer/react-intersection-observer.modern.mjs\");\n/* harmony import */ var src_components_Modal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/components/Modal */ \"./src/components/Modal/index.ts\");\n/* harmony import */ var src_components_Button__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/components/Button */ \"./src/components/Button/index.tsx\");\n/* harmony import */ var src_dashboard_actions_dashboardState__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/dashboard/actions/dashboardState */ \"./src/dashboard/actions/dashboardState.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/style/index.tsx\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @superset-ui/core */ \"./packages/superset-ui-core/src/translation/TranslatorSingleton.ts\");\n/* harmony import */ var src_dashboard_util_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! src/dashboard/util/constants */ \"./src/dashboard/util/constants.ts\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/* module decorator */ module = __webpack_require__.hmd(module);\n(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\n\n\n\n\n\nconst STICKY_HEADER_TOP = 16;\nconst STICKY_HEADER_HEIGHT = 32;\nconst StyledTitle = _superset_ui_core__WEBPACK_IMPORTED_MODULE_8__.styled.h2`\n  ${(_ref) => {let { theme } = _ref;return `\n     color:  ${theme.colors.grayscale.dark1}\n   `;}}\n`;\nconst StyledEditor = _superset_ui_core__WEBPACK_IMPORTED_MODULE_8__.styled.div`\n  ${(_ref2) => {let { theme } = _ref2;return `\n     table {\n       border: 1px ${theme.colors.grayscale.light2} solid;\n     }\n     pre {\n       font-size: 11px;\n       padding: 0px;\n       background-color: transparent;\n       border: 0px;\n       line-height: 110%;\n     }\n   `;}}\n`;\nconst StackableHeader = (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_8__.styled)((0,src_components_Button__WEBPACK_IMPORTED_MODULE_5__[\"default\"]))`\n  ${(_ref3) => {let { theme, top } = _ref3;return `\n     position: sticky;\n     top: ${top}px;\n     background-color: ${theme.colors.grayscale.light5};\n     margin: 0px;\n     padding: 8px 4px;\n     z-index: 1;\n     border: 0px;\n     border-radius: 0px;\n     width: 100%;\n     justify-content: flex-start;\n     border-bottom: 1px ${theme.colors.grayscale.light1} solid;\n     &::before {\n       display: inline-block;\n       position: relative;\n       opacity: 1;\n       content: \"\\\\00BB\";\n     }\n   `;}}\n`;\nconst StyledBottom = _superset_ui_core__WEBPACK_IMPORTED_MODULE_8__.styled.div`\n  ${(_ref4) => {let { inView } = _ref4;return `\n     margin: 8px auto;\n     text-align: center;\n     opacity: ${inView ? 0 : 1};\n  `;}}\n`;\nconst OverrideConfirmModal = (_ref5) => {let { overwriteConfirmMetadata } = _ref5;\n  const [bottomRef, hasReviewed] = (0,react_intersection_observer__WEBPACK_IMPORTED_MODULE_9__.useInView)({ triggerOnce: true });\n  const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.useDispatch)();\n  const onHide = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => dispatch((0,src_dashboard_actions_dashboardState__WEBPACK_IMPORTED_MODULE_6__.setOverrideConfirm)(undefined)), [dispatch]);\n  const anchors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => overwriteConfirmMetadata ?\n  overwriteConfirmMetadata.overwriteConfirmItems.map(() => /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()) :\n  [], [overwriteConfirmMetadata]);\n  const onAnchorClicked = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((index) => {var _anchors$index, _anchors$index$curren;\n    (_anchors$index = anchors[index]) == null ? void 0 : (_anchors$index$curren = _anchors$index.current) == null ? void 0 : _anchors$index$curren.scrollIntoView({ behavior: 'smooth' });\n  }, [anchors]);\n  const onConfirmOverwrite = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (overwriteConfirmMetadata) {\n      dispatch((0,src_dashboard_actions_dashboardState__WEBPACK_IMPORTED_MODULE_6__.saveDashboardRequest)(overwriteConfirmMetadata.data, overwriteConfirmMetadata.dashboardId, src_dashboard_util_constants__WEBPACK_IMPORTED_MODULE_7__.SAVE_TYPE_OVERWRITE_CONFIRMED));\n    }\n  }, [dispatch, overwriteConfirmMetadata]);\n  return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(src_components_Modal__WEBPACK_IMPORTED_MODULE_4__[\"default\"], { responsive: true, maxWidth: \"1024px\", height: \"50vh\", show: Boolean(overwriteConfirmMetadata), title: (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('Confirm overwrite'), footer: (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n    (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('Scroll down to the bottom to enable overwriting changes. '),\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(src_components_Button__WEBPACK_IMPORTED_MODULE_5__[\"default\"], { htmlType: \"button\", buttonSize: \"small\", onClick: onHide, \"data-test\": \"override-confirm-modal-cancel-button\", cta: true },\n    (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('No')\n    ),\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(src_components_Button__WEBPACK_IMPORTED_MODULE_5__[\"default\"], { \"data-test\": \"overwrite-confirm-save-button\", htmlType: \"button\", buttonSize: \"small\", cta: true, buttonStyle: \"primary\", onClick: onConfirmOverwrite, disabled: !hasReviewed },\n    (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('Yes, overwrite changes')\n    )\n    ), onHide: onHide },\n  overwriteConfirmMetadata && (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(StyledTitle, null,\n  (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('Are you sure you intend to overwrite the following values?')\n  ),\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(StyledEditor, null,\n  overwriteConfirmMetadata.overwriteConfirmItems.map((_ref6, index) => {let { keyPath, oldValue, newValue } = _ref6;return (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, { key: keyPath },\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(\"div\", { ref: anchors[index] }),\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(StackableHeader, { top: index * STICKY_HEADER_HEIGHT - STICKY_HEADER_TOP, buttonStyle: \"tertiary\", onClick: () => onAnchorClicked(index) },\n    keyPath\n    ),\n    (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(react_diff_viewer_continued__WEBPACK_IMPORTED_MODULE_3__[\"default\"], { oldValue: oldValue, newValue: newValue, leftTitle: (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('Last Updated %s by %s', moment__WEBPACK_IMPORTED_MODULE_1___default().utc(overwriteConfirmMetadata.updatedAt).calendar(), overwriteConfirmMetadata.updatedBy), rightTitle: \"new value\" })\n    );}),\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(StyledBottom, { ref: bottomRef, inView: hasReviewed },\n\n  (0,_emotion_react__WEBPACK_IMPORTED_MODULE_10__.jsx)(src_components_Button__WEBPACK_IMPORTED_MODULE_5__[\"default\"], { htmlType: \"button\", buttonSize: \"small\", cta: true, buttonStyle: \"primary\", onClick: onConfirmOverwrite },\n  (0,_superset_ui_core__WEBPACK_IMPORTED_MODULE_11__.t)('Yes, overwrite changes')\n  )\n  )\n  )\n  )\n  );\n};__signature__(OverrideConfirmModal, \"useInView{[bottomRef, hasReviewed]}\\nuseDispatch{dispatch}\\nuseCallback{onHide}\\nuseMemo{anchors}\\nuseCallback{onAnchorClicked}\\nuseCallback{onConfirmOverwrite}\", () => [react_intersection_observer__WEBPACK_IMPORTED_MODULE_9__.useInView, react_redux__WEBPACK_IMPORTED_MODULE_2__.useDispatch]);const _default =\nOverrideConfirmModal;/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_default);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(STICKY_HEADER_TOP, \"STICKY_HEADER_TOP\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(STICKY_HEADER_HEIGHT, \"STICKY_HEADER_HEIGHT\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(StyledTitle, \"StyledTitle\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(StyledEditor, \"StyledEditor\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(StackableHeader, \"StackableHeader\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(StyledBottom, \"StyledBottom\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(OverrideConfirmModal, \"OverrideConfirmModal\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");reactHotLoader.register(_default, \"default\", \"/app/superset-frontend/src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZGFzaGJvYXJkL2NvbXBvbmVudHMvT3ZlcndyaXRlQ29uZmlybS9PdmVyd3JpdGVDb25maXJtTW9kYWwudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FBUUE7Ozs7Ozs7QUFPQTtBQUNBO0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBR0E7QUFHQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7O0FBUUE7QUFFQTtBQVNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBVUE7QUFHQTs7QUFFQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL3NyYy9kYXNoYm9hcmQvY29tcG9uZW50cy9PdmVyd3JpdGVDb25maXJtL092ZXJ3cml0ZUNvbmZpcm1Nb2RhbC50c3g/NDM5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QsIHsgdXNlTWVtbywgdXNlQ2FsbGJhY2ssIFJlZk9iamVjdCwgY3JlYXRlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgdXNlRGlzcGF0Y2ggfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgUmVhY3REaWZmVmlld2VyIGZyb20gJ3JlYWN0LWRpZmYtdmlld2VyLWNvbnRpbnVlZCc7XG5pbXBvcnQgeyB1c2VJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuaW1wb3J0IE1vZGFsIGZyb20gJ3NyYy9jb21wb25lbnRzL01vZGFsJztcbmltcG9ydCBCdXR0b24gZnJvbSAnc3JjL2NvbXBvbmVudHMvQnV0dG9uJztcbmltcG9ydCB7IERhc2hib2FyZFN0YXRlIH0gZnJvbSAnc3JjL2Rhc2hib2FyZC90eXBlcyc7XG5pbXBvcnQge1xuICBzYXZlRGFzaGJvYXJkUmVxdWVzdCxcbiAgc2V0T3ZlcnJpZGVDb25maXJtLFxufSBmcm9tICdzcmMvZGFzaGJvYXJkL2FjdGlvbnMvZGFzaGJvYXJkU3RhdGUnO1xuaW1wb3J0IHsgdCwgc3R5bGVkIH0gZnJvbSAnQHN1cGVyc2V0LXVpL2NvcmUnO1xuaW1wb3J0IHsgU0FWRV9UWVBFX09WRVJXUklURV9DT05GSVJNRUQgfSBmcm9tICdzcmMvZGFzaGJvYXJkL3V0aWwvY29uc3RhbnRzJztcblxuY29uc3QgU1RJQ0tZX0hFQURFUl9UT1AgPSAxNjtcbmNvbnN0IFNUSUNLWV9IRUFERVJfSEVJR0hUID0gMzI7XG5cbmNvbnN0IFN0eWxlZFRpdGxlID0gc3R5bGVkLmgyYFxuICAkeyh7IHRoZW1lIH0pID0+IGBcbiAgICAgY29sb3I6ICAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUuZGFyazF9XG4gICBgfVxuYDtcblxuY29uc3QgU3R5bGVkRWRpdG9yID0gc3R5bGVkLmRpdmBcbiAgJHsoeyB0aGVtZSB9KSA9PiBgXG4gICAgIHRhYmxlIHtcbiAgICAgICBib3JkZXI6IDFweCAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQyfSBzb2xpZDtcbiAgICAgfVxuICAgICBwcmUge1xuICAgICAgIGZvbnQtc2l6ZTogMTFweDtcbiAgICAgICBwYWRkaW5nOiAwcHg7XG4gICAgICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgYm9yZGVyOiAwcHg7XG4gICAgICAgbGluZS1oZWlnaHQ6IDExMCU7XG4gICAgIH1cbiAgIGB9XG5gO1xuXG5jb25zdCBTdGFja2FibGVIZWFkZXIgPSBzdHlsZWQoQnV0dG9uKTx7IHRvcDogbnVtYmVyIH0+YFxuICAkeyh7IHRoZW1lLCB0b3AgfSkgPT4gYFxuICAgICBwb3NpdGlvbjogc3RpY2t5O1xuICAgICB0b3A6ICR7dG9wfXB4O1xuICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQ1fTtcbiAgICAgbWFyZ2luOiAwcHg7XG4gICAgIHBhZGRpbmc6IDhweCA0cHg7XG4gICAgIHotaW5kZXg6IDE7XG4gICAgIGJvcmRlcjogMHB4O1xuICAgICBib3JkZXItcmFkaXVzOiAwcHg7XG4gICAgIHdpZHRoOiAxMDAlO1xuICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgIGJvcmRlci1ib3R0b206IDFweCAke3RoZW1lLmNvbG9ycy5ncmF5c2NhbGUubGlnaHQxfSBzb2xpZDtcbiAgICAgJjo6YmVmb3JlIHtcbiAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgIG9wYWNpdHk6IDE7XG4gICAgICAgY29udGVudDogXCJcXFxcMDBCQlwiO1xuICAgICB9XG4gICBgfVxuYDtcblxuY29uc3QgU3R5bGVkQm90dG9tID0gc3R5bGVkLmRpdjx7IGluVmlldzogYm9vbGVhbiB9PmBcbiAgJHsoeyBpblZpZXcgfSkgPT4gYFxuICAgICBtYXJnaW46IDhweCBhdXRvO1xuICAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgIG9wYWNpdHk6ICR7aW5WaWV3ID8gMCA6IDF9O1xuICBgfVxuYDtcblxudHlwZSBQcm9wcyA9IHtcbiAgb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhOiBEYXNoYm9hcmRTdGF0ZVsnb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhJ107XG59O1xuXG5jb25zdCBPdmVycmlkZUNvbmZpcm1Nb2RhbCA9ICh7IG92ZXJ3cml0ZUNvbmZpcm1NZXRhZGF0YSB9OiBQcm9wcykgPT4ge1xuICBjb25zdCBbYm90dG9tUmVmLCBoYXNSZXZpZXdlZF0gPSB1c2VJblZpZXcoeyB0cmlnZ2VyT25jZTogdHJ1ZSB9KTtcbiAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xuICBjb25zdCBvbkhpZGUgPSB1c2VDYWxsYmFjayhcbiAgICAoKSA9PiBkaXNwYXRjaChzZXRPdmVycmlkZUNvbmZpcm0odW5kZWZpbmVkKSksXG4gICAgW2Rpc3BhdGNoXSxcbiAgKTtcbiAgY29uc3QgYW5jaG9ycyA9IHVzZU1lbW88UmVmT2JqZWN0PEhUTUxEaXZFbGVtZW50PltdPihcbiAgICAoKSA9PlxuICAgICAgb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhXG4gICAgICAgID8gb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhLm92ZXJ3cml0ZUNvbmZpcm1JdGVtcy5tYXAoKCkgPT5cbiAgICAgICAgICAgIGNyZWF0ZVJlZjxIVE1MRGl2RWxlbWVudD4oKSxcbiAgICAgICAgICApXG4gICAgICAgIDogW10sXG4gICAgW292ZXJ3cml0ZUNvbmZpcm1NZXRhZGF0YV0sXG4gICk7XG4gIGNvbnN0IG9uQW5jaG9yQ2xpY2tlZCA9IHVzZUNhbGxiYWNrKFxuICAgIChpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICBhbmNob3JzW2luZGV4XT8uY3VycmVudD8uc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgfSxcbiAgICBbYW5jaG9yc10sXG4gICk7XG4gIGNvbnN0IG9uQ29uZmlybU92ZXJ3cml0ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAob3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhKSB7XG4gICAgICBkaXNwYXRjaChcbiAgICAgICAgc2F2ZURhc2hib2FyZFJlcXVlc3QoXG4gICAgICAgICAgb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhLmRhdGEsXG4gICAgICAgICAgb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhLmRhc2hib2FyZElkLFxuICAgICAgICAgIFNBVkVfVFlQRV9PVkVSV1JJVEVfQ09ORklSTUVELFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gIH0sIFtkaXNwYXRjaCwgb3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8TW9kYWxcbiAgICAgIHJlc3BvbnNpdmVcbiAgICAgIG1heFdpZHRoPVwiMTAyNHB4XCJcbiAgICAgIGhlaWdodD1cIjUwdmhcIlxuICAgICAgc2hvdz17Qm9vbGVhbihvdmVyd3JpdGVDb25maXJtTWV0YWRhdGEpfVxuICAgICAgdGl0bGU9e3QoJ0NvbmZpcm0gb3ZlcndyaXRlJyl9XG4gICAgICBmb290ZXI9e1xuICAgICAgICA8PlxuICAgICAgICAgIHt0KCdTY3JvbGwgZG93biB0byB0aGUgYm90dG9tIHRvIGVuYWJsZSBvdmVyd3JpdGluZyBjaGFuZ2VzLiAnKX1cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBodG1sVHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICBidXR0b25TaXplPVwic21hbGxcIlxuICAgICAgICAgICAgb25DbGljaz17b25IaWRlfVxuICAgICAgICAgICAgZGF0YS10ZXN0PVwib3ZlcnJpZGUtY29uZmlybS1tb2RhbC1jYW5jZWwtYnV0dG9uXCJcbiAgICAgICAgICAgIGN0YVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0KCdObycpfVxuICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIGRhdGEtdGVzdD1cIm92ZXJ3cml0ZS1jb25maXJtLXNhdmUtYnV0dG9uXCJcbiAgICAgICAgICAgIGh0bWxUeXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIGJ1dHRvblNpemU9XCJzbWFsbFwiXG4gICAgICAgICAgICBjdGFcbiAgICAgICAgICAgIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiXG4gICAgICAgICAgICBvbkNsaWNrPXtvbkNvbmZpcm1PdmVyd3JpdGV9XG4gICAgICAgICAgICBkaXNhYmxlZD17IWhhc1Jldmlld2VkfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0KCdZZXMsIG92ZXJ3cml0ZSBjaGFuZ2VzJyl9XG4gICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgIDwvPlxuICAgICAgfVxuICAgICAgb25IaWRlPXtvbkhpZGV9XG4gICAgPlxuICAgICAge292ZXJ3cml0ZUNvbmZpcm1NZXRhZGF0YSAmJiAoXG4gICAgICAgIDw+XG4gICAgICAgICAgPFN0eWxlZFRpdGxlPlxuICAgICAgICAgICAge3QoJ0FyZSB5b3Ugc3VyZSB5b3UgaW50ZW5kIHRvIG92ZXJ3cml0ZSB0aGUgZm9sbG93aW5nIHZhbHVlcz8nKX1cbiAgICAgICAgICA8L1N0eWxlZFRpdGxlPlxuICAgICAgICAgIDxTdHlsZWRFZGl0b3I+XG4gICAgICAgICAgICB7b3ZlcndyaXRlQ29uZmlybU1ldGFkYXRhLm92ZXJ3cml0ZUNvbmZpcm1JdGVtcy5tYXAoXG4gICAgICAgICAgICAgICh7IGtleVBhdGgsIG9sZFZhbHVlLCBuZXdWYWx1ZSB9LCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgIDxSZWFjdC5GcmFnbWVudCBrZXk9e2tleVBhdGh9PlxuICAgICAgICAgICAgICAgICAgPGRpdiByZWY9e2FuY2hvcnNbaW5kZXhdfSAvPlxuICAgICAgICAgICAgICAgICAgPFN0YWNrYWJsZUhlYWRlclxuICAgICAgICAgICAgICAgICAgICB0b3A9e2luZGV4ICogU1RJQ0tZX0hFQURFUl9IRUlHSFQgLSBTVElDS1lfSEVBREVSX1RPUH1cbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uU3R5bGU9XCJ0ZXJ0aWFyeVwiXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IG9uQW5jaG9yQ2xpY2tlZChpbmRleCl9XG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIHtrZXlQYXRofVxuICAgICAgICAgICAgICAgICAgPC9TdGFja2FibGVIZWFkZXI+XG4gICAgICAgICAgICAgICAgICA8UmVhY3REaWZmVmlld2VyXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlPXtvbGRWYWx1ZX1cbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU9e25ld1ZhbHVlfVxuICAgICAgICAgICAgICAgICAgICBsZWZ0VGl0bGU9e3QoXG4gICAgICAgICAgICAgICAgICAgICAgJ0xhc3QgVXBkYXRlZCAlcyBieSAlcycsXG4gICAgICAgICAgICAgICAgICAgICAgbW9tZW50LnV0YyhvdmVyd3JpdGVDb25maXJtTWV0YWRhdGEudXBkYXRlZEF0KS5jYWxlbmRhcigpLFxuICAgICAgICAgICAgICAgICAgICAgIG92ZXJ3cml0ZUNvbmZpcm1NZXRhZGF0YS51cGRhdGVkQnksXG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0VGl0bGU9XCJuZXcgdmFsdWVcIlxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDxTdHlsZWRCb3R0b20gcmVmPXtib3R0b21SZWZ9IGluVmlldz17aGFzUmV2aWV3ZWR9PlxuICAgICAgICAgICAgICB7LyogQWRkIHN1Ym1pdCBidXR0b24gYXQgdGhlIGJvdHRvbSBpbiBjYXNlIG9mIGludGVyc2VjdGlvbi1vYnNlcnZlciBmYWxsYmFjayAqL31cbiAgICAgICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgICAgIGh0bWxUeXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgICAgICBidXR0b25TaXplPVwic21hbGxcIlxuICAgICAgICAgICAgICAgIGN0YVxuICAgICAgICAgICAgICAgIGJ1dHRvblN0eWxlPVwicHJpbWFyeVwiXG4gICAgICAgICAgICAgICAgb25DbGljaz17b25Db25maXJtT3ZlcndyaXRlfVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge3QoJ1llcywgb3ZlcndyaXRlIGNoYW5nZXMnKX1cbiAgICAgICAgICAgICAgPC9CdXR0b24+XG4gICAgICAgICAgICA8L1N0eWxlZEJvdHRvbT5cbiAgICAgICAgICA8L1N0eWxlZEVkaXRvcj5cbiAgICAgICAgPC8+XG4gICAgICApfVxuICAgIDwvTW9kYWw+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBPdmVycmlkZUNvbmZpcm1Nb2RhbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/dashboard/components/OverwriteConfirm/OverwriteConfirmModal.tsx\n");

/***/ }),

/***/ "./node_modules/react-intersection-observer/react-intersection-observer.modern.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/react-intersection-observer/react-intersection-observer.modern.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useInView: () => (/* binding */ useInView)\n/* harmony export */ });\n/* unused harmony exports InView, defaultFallbackInView, observe */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nconst observerMap = new Map();\nconst RootIds = new WeakMap();\nlet rootId = 0;\nlet unsupportedValue = undefined;\n/**\r\n * What should be the default behavior if the IntersectionObserver is unsupported?\r\n * Ideally the polyfill has been loaded, you can have the following happen:\r\n * - `undefined`: Throw an error\r\n * - `true` or `false`: Set the `inView` value to this regardless of intersection state\r\n * **/\n\nfunction defaultFallbackInView(inView) {\n  unsupportedValue = inView;\n}\n/**\r\n * Generate a unique ID for the root element\r\n * @param root\r\n */\n\nfunction getRootId(root) {\n  if (!root) return '0';\n  if (RootIds.has(root)) return RootIds.get(root);\n  rootId += 1;\n  RootIds.set(root, rootId.toString());\n  return RootIds.get(root);\n}\n/**\r\n * Convert the options to a string Id, based on the values.\r\n * Ensures we can reuse the same observer when observing elements with the same options.\r\n * @param options\r\n */\n\n\nfunction optionsToId(options) {\n  return Object.keys(options).sort().filter(key => options[key] !== undefined).map(key => {\n    return `${key}_${key === 'root' ? getRootId(options.root) : options[key]}`;\n  }).toString();\n}\n\nfunction createObserver(options) {\n  // Create a unique ID for this observer instance, based on the root, root margin and threshold.\n  let id = optionsToId(options);\n  let instance = observerMap.get(id);\n\n  if (!instance) {\n    // Create a map of elements this observer is going to observe. Each element has a list of callbacks that should be triggered, once it comes into view.\n    const elements = new Map();\n    let thresholds;\n    const observer = new IntersectionObserver(entries => {\n      entries.forEach(entry => {\n        var _elements$get;\n\n        // While it would be nice if you could just look at isIntersecting to determine if the component is inside the viewport, browsers can't agree on how to use it.\n        // -Firefox ignores `threshold` when considering `isIntersecting`, so it will never be false again if `threshold` is > 0\n        const inView = entry.isIntersecting && thresholds.some(threshold => entry.intersectionRatio >= threshold); // @ts-ignore support IntersectionObserver v2\n\n        if (options.trackVisibility && typeof entry.isVisible === 'undefined') {\n          // The browser doesn't support Intersection Observer v2, falling back to v1 behavior.\n          // @ts-ignore\n          entry.isVisible = inView;\n        }\n\n        (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach(callback => {\n          callback(inView, entry);\n        });\n      });\n    }, options); // Ensure we have a valid thresholds array. If not, use the threshold from the options\n\n    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);\n    instance = {\n      id,\n      observer,\n      elements\n    };\n    observerMap.set(id, instance);\n  }\n\n  return instance;\n}\n/**\r\n * @param element - DOM Element to observe\r\n * @param callback - Callback function to trigger when intersection status changes\r\n * @param options - Intersection Observer options\r\n * @param fallbackInView - Fallback inView value.\r\n * @return Function - Cleanup function that should be triggered to unregister the observer\r\n */\n\n\nfunction observe(element, callback, options = {}, fallbackInView = unsupportedValue) {\n  if (typeof window.IntersectionObserver === 'undefined' && fallbackInView !== undefined) {\n    const bounds = element.getBoundingClientRect();\n    callback(fallbackInView, {\n      isIntersecting: fallbackInView,\n      target: element,\n      intersectionRatio: typeof options.threshold === 'number' ? options.threshold : 0,\n      time: 0,\n      boundingClientRect: bounds,\n      intersectionRect: bounds,\n      rootBounds: bounds\n    });\n    return () => {// Nothing to cleanup\n    };\n  } // An observer with the same options can be reused, so lets use this fact\n\n\n  const {\n    id,\n    observer,\n    elements\n  } = createObserver(options); // Register the callback listener for this element\n\n  let callbacks = elements.get(element) || [];\n\n  if (!elements.has(element)) {\n    elements.set(element, callbacks);\n  }\n\n  callbacks.push(callback);\n  observer.observe(element);\n  return function unobserve() {\n    // Remove the callback from the callback list\n    callbacks.splice(callbacks.indexOf(callback), 1);\n\n    if (callbacks.length === 0) {\n      // No more callback exists for element, so destroy it\n      elements.delete(element);\n      observer.unobserve(element);\n    }\n\n    if (elements.size === 0) {\n      // No more elements are being observer by this instance, so destroy it\n      observer.disconnect();\n      observerMap.delete(id);\n    }\n  };\n}\n\nconst _excluded = [\"children\", \"as\", \"triggerOnce\", \"threshold\", \"root\", \"rootMargin\", \"onChange\", \"skip\", \"trackVisibility\", \"delay\", \"initialInView\", \"fallbackInView\"];\n\nfunction isPlainChildren(props) {\n  return typeof props.children !== 'function';\n}\n/**\r\n ## Render props\r\n\n To use the `<InView>` component, you pass it a function. It will be called\r\n whenever the state changes, with the new value of `inView`. In addition to the\r\n `inView` prop, children also receive a `ref` that should be set on the\r\n containing DOM element. This is the element that the IntersectionObserver will\r\n monitor.\r\n\n If you need it, you can also access the\r\n [`IntersectionObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry)\r\n on `entry`, giving you access to all the details about the current intersection\r\n state.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView>\r\n {({ inView, ref, entry }) => (\r\n      <div ref={ref}>\r\n        <h2>{`Header inside viewport ${inView}.`}</h2>\r\n      </div>\r\n    )}\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n\n ## Plain children\r\n\n You can pass any element to the `<InView />`, and it will handle creating the\r\n wrapping DOM element. Add a handler to the `onChange` method, and control the\r\n state in your own component. Any extra props you add to `<InView>` will be\r\n passed to the HTML element, allowing you set the `className`, `style`, etc.\r\n\n ```jsx\r\n import { InView } from 'react-intersection-observer';\r\n\n const Component = () => (\r\n <InView as=\"div\" onChange={(inView, entry) => console.log('Inview:', inView)}>\r\n <h2>Plain children are always rendered. Use onChange to monitor state.</h2>\r\n </InView>\r\n );\r\n\n export default Component;\r\n ```\r\n */\n\n\nclass InView extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n  constructor(props) {\n    super(props);\n    this.node = null;\n    this._unobserveCb = null;\n\n    this.handleNode = node => {\n      if (this.node) {\n        // Clear the old observer, before we start observing a new element\n        this.unobserve();\n\n        if (!node && !this.props.triggerOnce && !this.props.skip) {\n          // Reset the state if we get a new node, and we aren't ignoring updates\n          this.setState({\n            inView: !!this.props.initialInView,\n            entry: undefined\n          });\n        }\n      }\n\n      this.node = node ? node : null;\n      this.observeNode();\n    };\n\n    this.handleChange = (inView, entry) => {\n      if (inView && this.props.triggerOnce) {\n        // If `triggerOnce` is true, we should stop observing the element.\n        this.unobserve();\n      }\n\n      if (!isPlainChildren(this.props)) {\n        // Store the current State, so we can pass it to the children in the next render update\n        // There's no reason to update the state for plain children, since it's not used in the rendering.\n        this.setState({\n          inView,\n          entry\n        });\n      }\n\n      if (this.props.onChange) {\n        // If the user is actively listening for onChange, always trigger it\n        this.props.onChange(inView, entry);\n      }\n    };\n\n    this.state = {\n      inView: !!props.initialInView,\n      entry: undefined\n    };\n  }\n\n  componentDidUpdate(prevProps) {\n    // If a IntersectionObserver option changed, reinit the observer\n    if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n      this.unobserve();\n      this.observeNode();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unobserve();\n    this.node = null;\n  }\n\n  observeNode() {\n    if (!this.node || this.props.skip) return;\n    const {\n      threshold,\n      root,\n      rootMargin,\n      trackVisibility,\n      delay,\n      fallbackInView\n    } = this.props;\n    this._unobserveCb = observe(this.node, this.handleChange, {\n      threshold,\n      root,\n      rootMargin,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay\n    }, fallbackInView);\n  }\n\n  unobserve() {\n    if (this._unobserveCb) {\n      this._unobserveCb();\n\n      this._unobserveCb = null;\n    }\n  }\n\n  render() {\n    if (!isPlainChildren(this.props)) {\n      const {\n        inView,\n        entry\n      } = this.state;\n      return this.props.children({\n        inView,\n        entry,\n        ref: this.handleNode\n      });\n    }\n\n    const _this$props = this.props,\n          {\n      children,\n      as\n    } = _this$props,\n          props = _objectWithoutPropertiesLoose(_this$props, _excluded);\n\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(as || 'div', _extends({\n      ref: this.handleNode\n    }, props), children);\n  }\n\n}\n\n/**\r\n * React Hooks make it easy to monitor the `inView` state of your components. Call\r\n * the `useInView` hook with the (optional) [options](#options) you need. It will\r\n * return an array containing a `ref`, the `inView` status and the current\r\n * [`entry`](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).\r\n * Assign the `ref` to the DOM element you want to monitor, and the hook will\r\n * report the status.\r\n *\r\n * @example\r\n * ```jsx\r\n * import React from 'react';\r\n * import { useInView } from 'react-intersection-observer';\r\n *\r\n * const Component = () => {\r\n *   const { ref, inView, entry } = useInView({\r\n *       threshold: 0,\r\n *   });\r\n *\r\n *   return (\r\n *     <div ref={ref}>\r\n *       <h2>{`Header inside viewport ${inView}.`}</h2>\r\n *     </div>\r\n *   );\r\n * };\r\n * ```\r\n */\n\nfunction useInView({\n  threshold,\n  delay,\n  trackVisibility,\n  rootMargin,\n  root,\n  triggerOnce,\n  skip,\n  initialInView,\n  fallbackInView,\n  onChange\n} = {}) {\n  var _state$entry;\n\n  const [ref, setRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const callback = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n    inView: !!initialInView,\n    entry: undefined\n  }); // Store the onChange callback in a `ref`, so we can access the latest instance\n  // inside the `useEffect`, but without triggering a rerender.\n\n  callback.current = onChange;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    // Ensure we have node ref, and that we shouldn't skip observing\n    if (skip || !ref) return;\n    let unobserve;\n    unobserve = observe(ref, (inView, entry) => {\n      setState({\n        inView,\n        entry\n      });\n      if (callback.current) callback.current(inView, entry);\n\n      if (entry.isIntersecting && triggerOnce && unobserve) {\n        // If it should only trigger once, unobserve the element after it's inView\n        unobserve();\n        unobserve = undefined;\n      }\n    }, {\n      root,\n      rootMargin,\n      threshold,\n      // @ts-ignore\n      trackVisibility,\n      // @ts-ignore\n      delay\n    }, fallbackInView);\n    return () => {\n      if (unobserve) {\n        unobserve();\n      }\n    };\n  }, // We break the rule here, because we aren't including the actual `threshold` variable\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [// If the threshold is an array, convert it to a string, so it won't change between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  Array.isArray(threshold) ? threshold.toString() : threshold, ref, root, rootMargin, triggerOnce, skip, trackVisibility, fallbackInView, delay]);\n  const entryTarget = (_state$entry = state.entry) == null ? void 0 : _state$entry.target;\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!ref && entryTarget && !triggerOnce && !skip) {\n      // If we don't have a node ref, then reset the state (unless the hook is set to only `triggerOnce` or `skip`)\n      // This ensures we correctly reflect the current state - If you aren't observing anything, then nothing is inView\n      setState({\n        inView: !!initialInView,\n        entry: undefined\n      });\n    }\n  }, [ref, entryTarget, triggerOnce, skip, initialInView]);\n  const result = [setRef, state.inView, state.entry]; // Support object destructuring, by adding the specific values.\n\n  result.ref = result[0];\n  result.inView = result[1];\n  result.entry = result[2];\n  return result;\n}\n\n\n//# sourceMappingURL=react-intersection-observer.modern.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyL3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlci5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdXBlcnNldC8uL25vZGVfbW9kdWxlcy9yZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIvcmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyLm1vZGVybi5tanM/ZjM5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5jb25zdCBvYnNlcnZlck1hcCA9IG5ldyBNYXAoKTtcbmNvbnN0IFJvb3RJZHMgPSBuZXcgV2Vha01hcCgpO1xubGV0IHJvb3RJZCA9IDA7XG5sZXQgdW5zdXBwb3J0ZWRWYWx1ZSA9IHVuZGVmaW5lZDtcbi8qKlxyXG4gKiBXaGF0IHNob3VsZCBiZSB0aGUgZGVmYXVsdCBiZWhhdmlvciBpZiB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgdW5zdXBwb3J0ZWQ/XHJcbiAqIElkZWFsbHkgdGhlIHBvbHlmaWxsIGhhcyBiZWVuIGxvYWRlZCwgeW91IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcgaGFwcGVuOlxyXG4gKiAtIGB1bmRlZmluZWRgOiBUaHJvdyBhbiBlcnJvclxyXG4gKiAtIGB0cnVlYCBvciBgZmFsc2VgOiBTZXQgdGhlIGBpblZpZXdgIHZhbHVlIHRvIHRoaXMgcmVnYXJkbGVzcyBvZiBpbnRlcnNlY3Rpb24gc3RhdGVcclxuICogKiovXG5cbmZ1bmN0aW9uIGRlZmF1bHRGYWxsYmFja0luVmlldyhpblZpZXcpIHtcbiAgdW5zdXBwb3J0ZWRWYWx1ZSA9IGluVmlldztcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhlIHJvb3QgZWxlbWVudFxyXG4gKiBAcGFyYW0gcm9vdFxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Um9vdElkKHJvb3QpIHtcbiAgaWYgKCFyb290KSByZXR1cm4gJzAnO1xuICBpZiAoUm9vdElkcy5oYXMocm9vdCkpIHJldHVybiBSb290SWRzLmdldChyb290KTtcbiAgcm9vdElkICs9IDE7XG4gIFJvb3RJZHMuc2V0KHJvb3QsIHJvb3RJZC50b1N0cmluZygpKTtcbiAgcmV0dXJuIFJvb3RJZHMuZ2V0KHJvb3QpO1xufVxuLyoqXHJcbiAqIENvbnZlcnQgdGhlIG9wdGlvbnMgdG8gYSBzdHJpbmcgSWQsIGJhc2VkIG9uIHRoZSB2YWx1ZXMuXHJcbiAqIEVuc3VyZXMgd2UgY2FuIHJldXNlIHRoZSBzYW1lIG9ic2VydmVyIHdoZW4gb2JzZXJ2aW5nIGVsZW1lbnRzIHdpdGggdGhlIHNhbWUgb3B0aW9ucy5cclxuICogQHBhcmFtIG9wdGlvbnNcclxuICovXG5cblxuZnVuY3Rpb24gb3B0aW9uc1RvSWQob3B0aW9ucykge1xuICByZXR1cm4gT2JqZWN0LmtleXMob3B0aW9ucykuc29ydCgpLmZpbHRlcihrZXkgPT4gb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpLm1hcChrZXkgPT4ge1xuICAgIHJldHVybiBgJHtrZXl9XyR7a2V5ID09PSAncm9vdCcgPyBnZXRSb290SWQob3B0aW9ucy5yb290KSA6IG9wdGlvbnNba2V5XX1gO1xuICB9KS50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zKSB7XG4gIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBvYnNlcnZlciBpbnN0YW5jZSwgYmFzZWQgb24gdGhlIHJvb3QsIHJvb3QgbWFyZ2luIGFuZCB0aHJlc2hvbGQuXG4gIGxldCBpZCA9IG9wdGlvbnNUb0lkKG9wdGlvbnMpO1xuICBsZXQgaW5zdGFuY2UgPSBvYnNlcnZlck1hcC5nZXQoaWQpO1xuXG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZWxlbWVudHMgdGhpcyBvYnNlcnZlciBpcyBnb2luZyB0byBvYnNlcnZlLiBFYWNoIGVsZW1lbnQgaGFzIGEgbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkLCBvbmNlIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdGhyZXNob2xkcztcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGVudHJpZXMuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIHZhciBfZWxlbWVudHMkZ2V0O1xuXG4gICAgICAgIC8vIFdoaWxlIGl0IHdvdWxkIGJlIG5pY2UgaWYgeW91IGNvdWxkIGp1c3QgbG9vayBhdCBpc0ludGVyc2VjdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0LCBicm93c2VycyBjYW4ndCBhZ3JlZSBvbiBob3cgdG8gdXNlIGl0LlxuICAgICAgICAvLyAtRmlyZWZveCBpZ25vcmVzIGB0aHJlc2hvbGRgIHdoZW4gY29uc2lkZXJpbmcgYGlzSW50ZXJzZWN0aW5nYCwgc28gaXQgd2lsbCBuZXZlciBiZSBmYWxzZSBhZ2FpbiBpZiBgdGhyZXNob2xkYCBpcyA+IDBcbiAgICAgICAgY29uc3QgaW5WaWV3ID0gZW50cnkuaXNJbnRlcnNlY3RpbmcgJiYgdGhyZXNob2xkcy5zb21lKHRocmVzaG9sZCA9PiBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+PSB0aHJlc2hvbGQpOyAvLyBAdHMtaWdub3JlIHN1cHBvcnQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgdjJcblxuICAgICAgICBpZiAob3B0aW9ucy50cmFja1Zpc2liaWxpdHkgJiYgdHlwZW9mIGVudHJ5LmlzVmlzaWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBUaGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgSW50ZXJzZWN0aW9uIE9ic2VydmVyIHYyLCBmYWxsaW5nIGJhY2sgdG8gdjEgYmVoYXZpb3IuXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGVudHJ5LmlzVmlzaWJsZSA9IGluVmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIChfZWxlbWVudHMkZ2V0ID0gZWxlbWVudHMuZ2V0KGVudHJ5LnRhcmdldCkpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudHMkZ2V0LmZvckVhY2goY2FsbGJhY2sgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKGluVmlldywgZW50cnkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpOyAvLyBFbnN1cmUgd2UgaGF2ZSBhIHZhbGlkIHRocmVzaG9sZHMgYXJyYXkuIElmIG5vdCwgdXNlIHRoZSB0aHJlc2hvbGQgZnJvbSB0aGUgb3B0aW9uc1xuXG4gICAgdGhyZXNob2xkcyA9IG9ic2VydmVyLnRocmVzaG9sZHMgfHwgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50aHJlc2hvbGQpID8gb3B0aW9ucy50aHJlc2hvbGQgOiBbb3B0aW9ucy50aHJlc2hvbGQgfHwgMF0pO1xuICAgIGluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvYnNlcnZlcixcbiAgICAgIGVsZW1lbnRzXG4gICAgfTtcbiAgICBvYnNlcnZlck1hcC5zZXQoaWQsIGluc3RhbmNlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbi8qKlxyXG4gKiBAcGFyYW0gZWxlbWVudCAtIERPTSBFbGVtZW50IHRvIG9ic2VydmVcclxuICogQHBhcmFtIGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gdHJpZ2dlciB3aGVuIGludGVyc2VjdGlvbiBzdGF0dXMgY2hhbmdlc1xyXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEludGVyc2VjdGlvbiBPYnNlcnZlciBvcHRpb25zXHJcbiAqIEBwYXJhbSBmYWxsYmFja0luVmlldyAtIEZhbGxiYWNrIGluVmlldyB2YWx1ZS5cclxuICogQHJldHVybiBGdW5jdGlvbiAtIENsZWFudXAgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkIHRvIHVucmVnaXN0ZXIgdGhlIG9ic2VydmVyXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIG9ic2VydmUoZWxlbWVudCwgY2FsbGJhY2ssIG9wdGlvbnMgPSB7fSwgZmFsbGJhY2tJblZpZXcgPSB1bnN1cHBvcnRlZFZhbHVlKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyID09PSAndW5kZWZpbmVkJyAmJiBmYWxsYmFja0luVmlldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjYWxsYmFjayhmYWxsYmFja0luVmlldywge1xuICAgICAgaXNJbnRlcnNlY3Rpbmc6IGZhbGxiYWNrSW5WaWV3LFxuICAgICAgdGFyZ2V0OiBlbGVtZW50LFxuICAgICAgaW50ZXJzZWN0aW9uUmF0aW86IHR5cGVvZiBvcHRpb25zLnRocmVzaG9sZCA9PT0gJ251bWJlcicgPyBvcHRpb25zLnRocmVzaG9sZCA6IDAsXG4gICAgICB0aW1lOiAwLFxuICAgICAgYm91bmRpbmdDbGllbnRSZWN0OiBib3VuZHMsXG4gICAgICBpbnRlcnNlY3Rpb25SZWN0OiBib3VuZHMsXG4gICAgICByb290Qm91bmRzOiBib3VuZHNcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4gey8vIE5vdGhpbmcgdG8gY2xlYW51cFxuICAgIH07XG4gIH0gLy8gQW4gb2JzZXJ2ZXIgd2l0aCB0aGUgc2FtZSBvcHRpb25zIGNhbiBiZSByZXVzZWQsIHNvIGxldHMgdXNlIHRoaXMgZmFjdFxuXG5cbiAgY29uc3Qge1xuICAgIGlkLFxuICAgIG9ic2VydmVyLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTsgLy8gUmVnaXN0ZXIgdGhlIGNhbGxiYWNrIGxpc3RlbmVyIGZvciB0aGlzIGVsZW1lbnRcblxuICBsZXQgY2FsbGJhY2tzID0gZWxlbWVudHMuZ2V0KGVsZW1lbnQpIHx8IFtdO1xuXG4gIGlmICghZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgZWxlbWVudHMuc2V0KGVsZW1lbnQsIGNhbGxiYWNrcyk7XG4gIH1cblxuICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBjYWxsYmFjayBsaXN0XG4gICAgY2FsbGJhY2tzLnNwbGljZShjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuXG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgY2FsbGJhY2sgZXhpc3RzIGZvciBlbGVtZW50LCBzbyBkZXN0cm95IGl0XG4gICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgZWxlbWVudHMgYXJlIGJlaW5nIG9ic2VydmVyIGJ5IHRoaXMgaW5zdGFuY2UsIHNvIGRlc3Ryb3kgaXRcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyTWFwLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJjaGlsZHJlblwiLCBcImFzXCIsIFwidHJpZ2dlck9uY2VcIiwgXCJ0aHJlc2hvbGRcIiwgXCJyb290XCIsIFwicm9vdE1hcmdpblwiLCBcIm9uQ2hhbmdlXCIsIFwic2tpcFwiLCBcInRyYWNrVmlzaWJpbGl0eVwiLCBcImRlbGF5XCIsIFwiaW5pdGlhbEluVmlld1wiLCBcImZhbGxiYWNrSW5WaWV3XCJdO1xuXG5mdW5jdGlvbiBpc1BsYWluQ2hpbGRyZW4ocHJvcHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9wcy5jaGlsZHJlbiAhPT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxyXG4gIyMgUmVuZGVyIHByb3BzXHJcblxuIFRvIHVzZSB0aGUgYDxJblZpZXc+YCBjb21wb25lbnQsIHlvdSBwYXNzIGl0IGEgZnVuY3Rpb24uIEl0IHdpbGwgYmUgY2FsbGVkXHJcbiB3aGVuZXZlciB0aGUgc3RhdGUgY2hhbmdlcywgd2l0aCB0aGUgbmV3IHZhbHVlIG9mIGBpblZpZXdgLiBJbiBhZGRpdGlvbiB0byB0aGVcclxuIGBpblZpZXdgIHByb3AsIGNoaWxkcmVuIGFsc28gcmVjZWl2ZSBhIGByZWZgIHRoYXQgc2hvdWxkIGJlIHNldCBvbiB0aGVcclxuIGNvbnRhaW5pbmcgRE9NIGVsZW1lbnQuIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB0aGUgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgd2lsbFxyXG4gbW9uaXRvci5cclxuXG4gSWYgeW91IG5lZWQgaXQsIHlvdSBjYW4gYWxzbyBhY2Nlc3MgdGhlXHJcbiBbYEludGVyc2VjdGlvbk9ic2VydmVyRW50cnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSlcclxuIG9uIGBlbnRyeWAsIGdpdmluZyB5b3UgYWNjZXNzIHRvIGFsbCB0aGUgZGV0YWlscyBhYm91dCB0aGUgY3VycmVudCBpbnRlcnNlY3Rpb25cclxuIHN0YXRlLlxyXG5cbiBgYGBqc3hcclxuIGltcG9ydCB7IEluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XHJcblxuIGNvbnN0IENvbXBvbmVudCA9ICgpID0+IChcclxuIDxJblZpZXc+XHJcbiB7KHsgaW5WaWV3LCByZWYsIGVudHJ5IH0pID0+IChcclxuICAgICAgPGRpdiByZWY9e3JlZn0+XHJcbiAgICAgICAgPGgyPntgSGVhZGVyIGluc2lkZSB2aWV3cG9ydCAke2luVmlld30uYH08L2gyPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICl9XHJcbiA8L0luVmlldz5cclxuICk7XHJcblxuIGV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcclxuIGBgYFxyXG5cbiAjIyBQbGFpbiBjaGlsZHJlblxyXG5cbiBZb3UgY2FuIHBhc3MgYW55IGVsZW1lbnQgdG8gdGhlIGA8SW5WaWV3IC8+YCwgYW5kIGl0IHdpbGwgaGFuZGxlIGNyZWF0aW5nIHRoZVxyXG4gd3JhcHBpbmcgRE9NIGVsZW1lbnQuIEFkZCBhIGhhbmRsZXIgdG8gdGhlIGBvbkNoYW5nZWAgbWV0aG9kLCBhbmQgY29udHJvbCB0aGVcclxuIHN0YXRlIGluIHlvdXIgb3duIGNvbXBvbmVudC4gQW55IGV4dHJhIHByb3BzIHlvdSBhZGQgdG8gYDxJblZpZXc+YCB3aWxsIGJlXHJcbiBwYXNzZWQgdG8gdGhlIEhUTUwgZWxlbWVudCwgYWxsb3dpbmcgeW91IHNldCB0aGUgYGNsYXNzTmFtZWAsIGBzdHlsZWAsIGV0Yy5cclxuXG4gYGBganN4XHJcbiBpbXBvcnQgeyBJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xyXG5cbiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiAoXHJcbiA8SW5WaWV3IGFzPVwiZGl2XCIgb25DaGFuZ2U9eyhpblZpZXcsIGVudHJ5KSA9PiBjb25zb2xlLmxvZygnSW52aWV3OicsIGluVmlldyl9PlxyXG4gPGgyPlBsYWluIGNoaWxkcmVuIGFyZSBhbHdheXMgcmVuZGVyZWQuIFVzZSBvbkNoYW5nZSB0byBtb25pdG9yIHN0YXRlLjwvaDI+XHJcbiA8L0luVmlldz5cclxuICk7XHJcblxuIGV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcclxuIGBgYFxyXG4gKi9cblxuXG5jbGFzcyBJblZpZXcgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLm5vZGUgPSBudWxsO1xuICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gbnVsbDtcblxuICAgIHRoaXMuaGFuZGxlTm9kZSA9IG5vZGUgPT4ge1xuICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAvLyBDbGVhciB0aGUgb2xkIG9ic2VydmVyLCBiZWZvcmUgd2Ugc3RhcnQgb2JzZXJ2aW5nIGEgbmV3IGVsZW1lbnRcbiAgICAgICAgdGhpcy51bm9ic2VydmUoKTtcblxuICAgICAgICBpZiAoIW5vZGUgJiYgIXRoaXMucHJvcHMudHJpZ2dlck9uY2UgJiYgIXRoaXMucHJvcHMuc2tpcCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSBzdGF0ZSBpZiB3ZSBnZXQgYSBuZXcgbm9kZSwgYW5kIHdlIGFyZW4ndCBpZ25vcmluZyB1cGRhdGVzXG4gICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICBpblZpZXc6ICEhdGhpcy5wcm9wcy5pbml0aWFsSW5WaWV3LFxuICAgICAgICAgICAgZW50cnk6IHVuZGVmaW5lZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMubm9kZSA9IG5vZGUgPyBub2RlIDogbnVsbDtcbiAgICAgIHRoaXMub2JzZXJ2ZU5vZGUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5oYW5kbGVDaGFuZ2UgPSAoaW5WaWV3LCBlbnRyeSkgPT4ge1xuICAgICAgaWYgKGluVmlldyAmJiB0aGlzLnByb3BzLnRyaWdnZXJPbmNlKSB7XG4gICAgICAgIC8vIElmIGB0cmlnZ2VyT25jZWAgaXMgdHJ1ZSwgd2Ugc2hvdWxkIHN0b3Agb2JzZXJ2aW5nIHRoZSBlbGVtZW50LlxuICAgICAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUGxhaW5DaGlsZHJlbih0aGlzLnByb3BzKSkge1xuICAgICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBTdGF0ZSwgc28gd2UgY2FuIHBhc3MgaXQgdG8gdGhlIGNoaWxkcmVuIGluIHRoZSBuZXh0IHJlbmRlciB1cGRhdGVcbiAgICAgICAgLy8gVGhlcmUncyBubyByZWFzb24gdG8gdXBkYXRlIHRoZSBzdGF0ZSBmb3IgcGxhaW4gY2hpbGRyZW4sIHNpbmNlIGl0J3Mgbm90IHVzZWQgaW4gdGhlIHJlbmRlcmluZy5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgaW5WaWV3LFxuICAgICAgICAgIGVudHJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAvLyBJZiB0aGUgdXNlciBpcyBhY3RpdmVseSBsaXN0ZW5pbmcgZm9yIG9uQ2hhbmdlLCBhbHdheXMgdHJpZ2dlciBpdFxuICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGluVmlldywgZW50cnkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaW5WaWV3OiAhIXByb3BzLmluaXRpYWxJblZpZXcsXG4gICAgICBlbnRyeTogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAvLyBJZiBhIEludGVyc2VjdGlvbk9ic2VydmVyIG9wdGlvbiBjaGFuZ2VkLCByZWluaXQgdGhlIG9ic2VydmVyXG4gICAgaWYgKHByZXZQcm9wcy5yb290TWFyZ2luICE9PSB0aGlzLnByb3BzLnJvb3RNYXJnaW4gfHwgcHJldlByb3BzLnJvb3QgIT09IHRoaXMucHJvcHMucm9vdCB8fCBwcmV2UHJvcHMudGhyZXNob2xkICE9PSB0aGlzLnByb3BzLnRocmVzaG9sZCB8fCBwcmV2UHJvcHMuc2tpcCAhPT0gdGhpcy5wcm9wcy5za2lwIHx8IHByZXZQcm9wcy50cmFja1Zpc2liaWxpdHkgIT09IHRoaXMucHJvcHMudHJhY2tWaXNpYmlsaXR5IHx8IHByZXZQcm9wcy5kZWxheSAhPT0gdGhpcy5wcm9wcy5kZWxheSkge1xuICAgICAgdGhpcy51bm9ic2VydmUoKTtcbiAgICAgIHRoaXMub2JzZXJ2ZU5vZGUoKTtcbiAgICB9XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICAgIHRoaXMubm9kZSA9IG51bGw7XG4gIH1cblxuICBvYnNlcnZlTm9kZSgpIHtcbiAgICBpZiAoIXRoaXMubm9kZSB8fCB0aGlzLnByb3BzLnNraXApIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICB0aHJlc2hvbGQsXG4gICAgICByb290LFxuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIGRlbGF5LFxuICAgICAgZmFsbGJhY2tJblZpZXdcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLl91bm9ic2VydmVDYiA9IG9ic2VydmUodGhpcy5ub2RlLCB0aGlzLmhhbmRsZUNoYW5nZSwge1xuICAgICAgdGhyZXNob2xkLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBkZWxheVxuICAgIH0sIGZhbGxiYWNrSW5WaWV3KTtcbiAgfVxuXG4gIHVub2JzZXJ2ZSgpIHtcbiAgICBpZiAodGhpcy5fdW5vYnNlcnZlQ2IpIHtcbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZUNiKCk7XG5cbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgaWYgKCFpc1BsYWluQ2hpbGRyZW4odGhpcy5wcm9wcykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5WaWV3LFxuICAgICAgICBlbnRyeVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih7XG4gICAgICAgIGluVmlldyxcbiAgICAgICAgZW50cnksXG4gICAgICAgIHJlZjogdGhpcy5oYW5kbGVOb2RlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBhc1xuICAgIH0gPSBfdGhpcyRwcm9wcyxcbiAgICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoYXMgfHwgJ2RpdicsIF9leHRlbmRzKHtcbiAgICAgIHJlZjogdGhpcy5oYW5kbGVOb2RlXG4gICAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG4gIH1cblxufVxuXG4vKipcclxuICogUmVhY3QgSG9va3MgbWFrZSBpdCBlYXN5IHRvIG1vbml0b3IgdGhlIGBpblZpZXdgIHN0YXRlIG9mIHlvdXIgY29tcG9uZW50cy4gQ2FsbFxyXG4gKiB0aGUgYHVzZUluVmlld2AgaG9vayB3aXRoIHRoZSAob3B0aW9uYWwpIFtvcHRpb25zXSgjb3B0aW9ucykgeW91IG5lZWQuIEl0IHdpbGxcclxuICogcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBgcmVmYCwgdGhlIGBpblZpZXdgIHN0YXR1cyBhbmQgdGhlIGN1cnJlbnRcclxuICogW2BlbnRyeWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KS5cclxuICogQXNzaWduIHRoZSBgcmVmYCB0byB0aGUgRE9NIGVsZW1lbnQgeW91IHdhbnQgdG8gbW9uaXRvciwgYW5kIHRoZSBob29rIHdpbGxcclxuICogcmVwb3J0IHRoZSBzdGF0dXMuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGBgYGpzeFxyXG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG4gKiBpbXBvcnQgeyB1c2VJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xyXG4gKlxyXG4gKiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAqICAgY29uc3QgeyByZWYsIGluVmlldywgZW50cnkgfSA9IHVzZUluVmlldyh7XHJcbiAqICAgICAgIHRocmVzaG9sZDogMCxcclxuICogICB9KTtcclxuICpcclxuICogICByZXR1cm4gKFxyXG4gKiAgICAgPGRpdiByZWY9e3JlZn0+XHJcbiAqICAgICAgIDxoMj57YEhlYWRlciBpbnNpZGUgdmlld3BvcnQgJHtpblZpZXd9LmB9PC9oMj5cclxuICogICAgIDwvZGl2PlxyXG4gKiAgICk7XHJcbiAqIH07XHJcbiAqIGBgYFxyXG4gKi9cblxuZnVuY3Rpb24gdXNlSW5WaWV3KHtcbiAgdGhyZXNob2xkLFxuICBkZWxheSxcbiAgdHJhY2tWaXNpYmlsaXR5LFxuICByb290TWFyZ2luLFxuICByb290LFxuICB0cmlnZ2VyT25jZSxcbiAgc2tpcCxcbiAgaW5pdGlhbEluVmlldyxcbiAgZmFsbGJhY2tJblZpZXcsXG4gIG9uQ2hhbmdlXG59ID0ge30pIHtcbiAgdmFyIF9zdGF0ZSRlbnRyeTtcblxuICBjb25zdCBbcmVmLCBzZXRSZWZdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNhbGxiYWNrID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGluVmlldzogISFpbml0aWFsSW5WaWV3LFxuICAgIGVudHJ5OiB1bmRlZmluZWRcbiAgfSk7IC8vIFN0b3JlIHRoZSBvbkNoYW5nZSBjYWxsYmFjayBpbiBhIGByZWZgLCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBsYXRlc3QgaW5zdGFuY2VcbiAgLy8gaW5zaWRlIHRoZSBgdXNlRWZmZWN0YCwgYnV0IHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlcmVuZGVyLlxuXG4gIGNhbGxiYWNrLmN1cnJlbnQgPSBvbkNoYW5nZTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBFbnN1cmUgd2UgaGF2ZSBub2RlIHJlZiwgYW5kIHRoYXQgd2Ugc2hvdWxkbid0IHNraXAgb2JzZXJ2aW5nXG4gICAgaWYgKHNraXAgfHwgIXJlZikgcmV0dXJuO1xuICAgIGxldCB1bm9ic2VydmU7XG4gICAgdW5vYnNlcnZlID0gb2JzZXJ2ZShyZWYsIChpblZpZXcsIGVudHJ5KSA9PiB7XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGluVmlldyxcbiAgICAgICAgZW50cnlcbiAgICAgIH0pO1xuICAgICAgaWYgKGNhbGxiYWNrLmN1cnJlbnQpIGNhbGxiYWNrLmN1cnJlbnQoaW5WaWV3LCBlbnRyeSk7XG5cbiAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyAmJiB0cmlnZ2VyT25jZSAmJiB1bm9ic2VydmUpIHtcbiAgICAgICAgLy8gSWYgaXQgc2hvdWxkIG9ubHkgdHJpZ2dlciBvbmNlLCB1bm9ic2VydmUgdGhlIGVsZW1lbnQgYWZ0ZXIgaXQncyBpblZpZXdcbiAgICAgICAgdW5vYnNlcnZlKCk7XG4gICAgICAgIHVub2JzZXJ2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICByb290LFxuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlbGF5XG4gICAgfSwgZmFsbGJhY2tJblZpZXcpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAodW5vYnNlcnZlKSB7XG4gICAgICAgIHVub2JzZXJ2ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIC8vIFdlIGJyZWFrIHRoZSBydWxlIGhlcmUsIGJlY2F1c2Ugd2UgYXJlbid0IGluY2x1ZGluZyB0aGUgYWN0dWFsIGB0aHJlc2hvbGRgIHZhcmlhYmxlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgWy8vIElmIHRoZSB0aHJlc2hvbGQgaXMgYW4gYXJyYXksIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcsIHNvIGl0IHdvbid0IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgQXJyYXkuaXNBcnJheSh0aHJlc2hvbGQpID8gdGhyZXNob2xkLnRvU3RyaW5nKCkgOiB0aHJlc2hvbGQsIHJlZiwgcm9vdCwgcm9vdE1hcmdpbiwgdHJpZ2dlck9uY2UsIHNraXAsIHRyYWNrVmlzaWJpbGl0eSwgZmFsbGJhY2tJblZpZXcsIGRlbGF5XSk7XG4gIGNvbnN0IGVudHJ5VGFyZ2V0ID0gKF9zdGF0ZSRlbnRyeSA9IHN0YXRlLmVudHJ5KSA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGVudHJ5LnRhcmdldDtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXJlZiAmJiBlbnRyeVRhcmdldCAmJiAhdHJpZ2dlck9uY2UgJiYgIXNraXApIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBub2RlIHJlZiwgdGhlbiByZXNldCB0aGUgc3RhdGUgKHVubGVzcyB0aGUgaG9vayBpcyBzZXQgdG8gb25seSBgdHJpZ2dlck9uY2VgIG9yIGBza2lwYClcbiAgICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBjb3JyZWN0bHkgcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZSAtIElmIHlvdSBhcmVuJ3Qgb2JzZXJ2aW5nIGFueXRoaW5nLCB0aGVuIG5vdGhpbmcgaXMgaW5WaWV3XG4gICAgICBzZXRTdGF0ZSh7XG4gICAgICAgIGluVmlldzogISFpbml0aWFsSW5WaWV3LFxuICAgICAgICBlbnRyeTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtyZWYsIGVudHJ5VGFyZ2V0LCB0cmlnZ2VyT25jZSwgc2tpcCwgaW5pdGlhbEluVmlld10pO1xuICBjb25zdCByZXN1bHQgPSBbc2V0UmVmLCBzdGF0ZS5pblZpZXcsIHN0YXRlLmVudHJ5XTsgLy8gU3VwcG9ydCBvYmplY3QgZGVzdHJ1Y3R1cmluZywgYnkgYWRkaW5nIHRoZSBzcGVjaWZpYyB2YWx1ZXMuXG5cbiAgcmVzdWx0LnJlZiA9IHJlc3VsdFswXTtcbiAgcmVzdWx0LmluVmlldyA9IHJlc3VsdFsxXTtcbiAgcmVzdWx0LmVudHJ5ID0gcmVzdWx0WzJdO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgeyBJblZpZXcsIGRlZmF1bHRGYWxsYmFja0luVmlldywgb2JzZXJ2ZSwgdXNlSW5WaWV3IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIubW9kZXJuLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/react-intersection-observer/react-intersection-observer.modern.mjs\n");

/***/ })

}]);